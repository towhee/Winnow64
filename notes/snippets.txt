// Qt version control
#if (QT_VERSION < QT_VERSION_CHECK(6, 0, 0))
    qDebug() << "CLASSFUNCTION" << progressLabel->pixmap()->width();
#else
    qDebug() << "CLASSFUNCTION" << progressLabel->pixmap(Qt::ReturnByValueConstant()).width();
#endif

// disable QAction shortcuts
QList<QAction*> actions = findChildren<QAction*>();
for (QAction *a : actions) a->setShortcutContext(Qt::WidgetShortcut);

// enable QAction shortcuts
QList<QAction*> actions = findChildren<QAction*>();
for (QAction *a : actions) a->setShortcutContext(Qt::WindowShortcut);


// delete windows registry in installer
"installscript.js"
...
Component.prototype.createOperations = function()
{
if (installer.value("os") == "win")
{
component.addElevatedOperation("Execute","echo do nothing","UNDOEXECUTE","cmd /C reg delete "HKEY_CURRENT_USER\Software\Company" /f")
...

The echo in the line is necessary, otherwise the installer crashes.
This seems to be a bug in the installer.
It works quite well, now all registry entries are deleted.


// applescript open in photoshop

on openInPhotoshop(filename, isbn)
    tell application "Adobe Photoshop CC 2017"
        activate
        set thisFile to filename as string
        open alias thisFile
        set a to 1
    end tell
end openInPhotoshop

// Create a label with a png file image
pickLabel = new QLabel(this);
pickLabel->setFixedSize(64,64);
pickLabel->setAttribute(Qt::WA_TranslucentBackground);
pickPixmap = new QPixmap(":/images/checkmark.png");
pickLabel->setAlignment(Qt::AlignRight | Qt::AlignBottom);
pickLabel->setVisible(false);


// memory stuff
struct sysinfo sys_info;
totalmem=(qint32)(sys_info.totalram/1048576);
freemem=(qint32)(sys_info.freeram/1048576); // divide by 1024*1024 = 1048576

// macos screen resolution
auto modes = CGDisplayCopyAllDisplayModes(mainDisplayId, nullptr);
auto count = CFArrayGetCount(modes);
CGDisplayModeRef mode;
int wMax, hMax = 0;
for(auto c=count;c--;){
    mode = (CGDisplayModeRef)CFArrayGetValueAtIndex(modes, c);
    auto w = CGDisplayModeGetWidth(mode);
    auto h = CGDisplayModeGetHeight(mode);
    if (w > wMax) wMax = (int)w;
    if (h > hMax) hMax = (int)h;
}
displayHorizontalPixels = wMax;
displayVerticalPixels = hMax;

// return the displayID from a global screen coordinate
CGPoint point;

CGDirectDisplayID getDisplay()
{
const int maxDisplays = 64;                     // 64 should be enough for any system
CGDisplayErr displayStatus;
CGDisplayCount displayCount;                    // Total number of display IDs
CGDirectDisplayID displayIDs[maxDisplays];	// Array of display IDs

displayStatus = CGGetDisplaysWithPoint (point, maxDisplays, displayIDs, &displayCount);
if (displayStatus != kCGErrorSuccess || displayCount!= 1)
{
printf("CGGetDisplaysWithPoint returned error or the wrong number of displays\n");
return NULL;
}
else
return displayIDs[0];
}

// iterate a list
QListWidget *list = new QListidget;
for (const auto& i : list) {
    qDebug() << i;
}


// Regular expression
QRegExp rx("^(Border|Text|Shape|Graphic)$");

if (rx.exactMatch(objectName) == true){
    // do something
}


// QString with arguments
statusBar()->showMessage(tr("Position: (%1,%2) in top level").arg(row).arg(column));
QString newTemplate = QString("New Template %1").arg(newTemplateCount);


// Algorithm to walk a tree structure
void DataModel::walkTree(const QModelIndex &row)
{
    if (this->hasChildren()) {
        for (int i = 0; i < rowCount(row); ++i){
            walkTree(this->index(i,0,row));
        }
    }
}

// Another walk tree
void forEach(QAbstractItemModel* model, QModelIndex parent = QModelIndex()) {
    for (int r = 0; r < model->rowCount(parent); ++r) {
        QModelIndex index = model->index(r, 0, parent);
        QVariant name = model->data(index);
        qDebug() << name;
        // here is your applicable code
        if( model->hasChildren(index) ) {
            forEach(model, index);
        }
    }
}

// convert Magick Image to QPixmap
void ITMagickGraphic::convertImageToPixmap()
{
Blob imageBlob;
image.magick("XPM");
image.write(&imageBlob);
const QByteArray imageData((char*)(imageBlob.data()),
imageBlob.length());
pixmapGraphic.loadFromData(imageData);
}

void ITMagickGraphic::convertPixmapToImage()
{
QByteArray newImageData;
QBuffer imageBuffer(&newImageData);
imageBuffer.open(QIODevice::WriteOnly);
pixmapGraphic.save(&imageBuffer,"JPEG");
Blob newImageBlob(newImageData.data(),newImageData.size());
Image
newImage(newImageBlob,Geometry(pixmapGraphic.width(),pixmapGraphic.height()),"jpeg");

image = newImage;
}

// working with char and uchar examples
char *buffer;
buffer = new char[length];

const char *buf = ba.data();

-----------
Count unique strings in list: (chatGPT)
#include <iostream>
#include <unordered_map>
#include <vector>

int main() {
    std::vector<std::string> my_list;
    // Add 100,000 strings to my_list

    std::unordered_map<std::string, int> count_map;
    for (const auto &str : my_list) {
        count_map[str]++;
    }

    for (const auto &[str, count] : count_map) {
        std::cout << str << ": " << count << std::endl;
    }

    return 0;
}

This example uses an unordered_map to keep track of the count of each unique string in
the list. The map stores the unique strings as keys and the count of each string as
values. The for loop iterates over the list of strings and for each string, increments
the count in the map. Finally, the program loops over the map and prints out the count of
each unique string.
-----------

Share an image on MacOS (ChatGPT)

(void)shareImage:(NSImage *)image {
    NSSharingServicePicker *picker = [[NSSharingServicePicker alloc] initWithItems:@[image]];
    [picker showRelativeToRect:[self.view bounds] ofView:self.view preferredEdge:NSRectEdgeMaxY];
}

#include <QtMacExtras/QMacPasteboardMime>
#include <QtGui/QImage>
#include <QtGui/QClipboard>

void shareImage(const QImage &image)
{
    // Convert the image to a png format
    QByteArray ba;
    QBuffer buffer(&ba);
    buffer.open(QIODevice::WriteOnly);
    image.save(&buffer, "PNG");

    // Put the image data on the clipboard
    QClipboard *clipboard = QGuiApplication::clipboard();
    clipboard->setMimeData(new QMimeData(), QClipboard::Clipboard);
    QMacPasteboardMime *mime = new QMacPasteboardMime(QStringLiteral("public.png"));
    mime->writeToPasteboard(clipboard->mimeData(), ba);
}

-----------------------
This code first converts the QImage to an NSImage using the toNSImage method, which is
provided by the QtMacExtras module. Then, an instance of NSSharingServicePicker is
created, configured and presented to the user, allowing them to choose from a variety of
sharing options, such as email, message, or social media.

#include <QtGui/QImage>
#include <QtMacExtras/QMacNativeWidget>
#include <AppKit/NSSharingServicePicker.h>

void shareImage(const QImage &image)
{
    // Convert the image to a native NSImage
    QMacNativeWidget nativeWidget;
    NSImage *nsImage = [[NSImage alloc] initWithData:[image.toNSImage().TIFFRepresentation() mutableCopy]];

    // Create an NSSharingServicePicker and present it
    NSSharingServicePicker *picker = [[NSSharingServicePicker alloc] init];
    [picker setDelegate:nil];
    [picker setShowsServicesButton:NO];
    [picker setSourceRect:NSZeroRect];
    [picker setSourceView:nativeWidget.nativeView()];
    [picker shareImage:nsImage];
}

-----------------------------------
From a Qt 6 environment, create a c++ function that accepts a QList containing multiple
QImages and shares the QImages on MacOS using NSSharingServicePicker.

Here is an example of how to share multiple images on MacOS using NSSharingServicePicker
from within a Qt 6 environment:

#include <QtGui/QImage>
#include <QtMacExtras/QMacNativeWidget>
#include <AppKit/NSSharingServicePicker.h>

void shareImages(const QList<QImage> &images)
{
    // Convert the QImages to native NSImages
    QMacNativeWidget nativeWidget;
    NSMutableArray *nsImages = [NSMutableArray array];
    for (const auto &image : images) {
        NSImage *nsImage = [[NSImage alloc] initWithData:[image.toNSImage().TIFFRepresentation() mutableCopy]];
        [nsImages addObject:nsImage];
    }

    // Create an NSSharingServicePicker and present it
    NSSharingServicePicker *picker = [[NSSharingServicePicker alloc] init];
    [picker setDelegate:nil];
    [picker setShowsServicesButton:NO];
    [picker setSourceRect:NSZeroRect];
    [picker setSourceView:nativeWidget.nativeView()];
    [picker shareImages:nsImages];
}

This code first converts each QImage in the list to a native NSImage using the toNSImage
method, which is provided by the QtMacExtras module. Then, an instance of
NSSharingServicePicker is created, configured and presented to the user, allowing them to
choose from a variety of sharing options, such as email, message, or social media. The
shareImages: method of NSSharingServicePicker is used to share the list of NSImages.

-----------------------------------
From a Qt 6 environment, create a c++ function that accepts a List containing multiple
image file urls and shares the files on MacOS using NSSharingServicePicker.

Here is an example of how to share multiple image files on MacOS using
NSSharingServicePicker from within a Qt 6 environment:

#include <QtCore/QList>
#include <QtCore/QUrl>
#include <QtMacExtras/QMacNativeWidget>
#include <AppKit/NSSharingServicePicker.h>

void shareImageFiles(const QList<QUrl> &fileUrls)
{
    // Convert the file urls to native NSURLs
    QMacNativeWidget nativeWidget;
    NSMutableArray *nsFileUrls = [NSMutableArray array];
    for (const auto &fileUrl : fileUrls) {
        NSURL *nsFileUrl = [NSURL fileURLWithPath:fileUrl.toLocalFile()];
        [nsFileUrls addObject:nsFileUrl];
    }

    // Create an NSSharingServicePicker and present it
    NSSharingServicePicker *picker = [[NSSharingServicePicker alloc] init];
    [picker setDelegate:nil];
    [picker setShowsServicesButton:NO];
    [picker setSourceRect:NSZeroRect];
    [picker setSourceView:nativeWidget.nativeView()];
    [picker shareFiles:nsFileUrls];
}

This code first converts each QUrl in the list to a native NSURL using the
fileURLWithPath method from NSURL. Then, an instance of NSSharingServicePicker
is created, configured and presented to the user, allowing them to choose from
a variety of sharing options, such as email, message, or social media. The
shareFiles: method of NSSharingServicePicker is used to share the list of file
URLs.
