test0       13
test1a      30
test2       24
test4       18

QString pendingFolderPath;
bool pendingToggle = false;
int countSubdirsFast(const QString &root, int hardCap);
QFutureWatcher<int> watcherCount;

FSTree::FSTree
    // Connect watcher signals to your own slots/signals
connect(&watcherCount, &QFutureWatcher<int>::finished, this, [this]() {
    int result = watcherCount.result();
    bool cancelled = G::stop;
    emit countFinished(result, cancelled);
});

// Connect your own signal to your slot
connect(this, &FSTree::countFinished, this, &FSTree::onCountFinished);

void FSTree::startCountSubdirs(const QString &root, int hardCap)
{
    if (watcherCount.isRunning()) {
        qDebug() << "FSTree::startCountSubdirs already running, ignoring";
        return;
    }

    G::stop = false;                 // reset cancellation flag
    isSelectingFolders = true;       // your existing state flag

    // Launch in background
    QFuture<int> futureCount = QtConcurrent::run([this, root, hardCap]() {
        return countSubdirsFast(root, hardCap);
    });

    watcherCount.setFuture(futureCount);
}

void FSTree::cancelCountSubdirs()
{
    if (watcherCount.isRunning()) {
        G::stop = true;
        watcherCount.waitForFinished();   // optional: block until done
    }
}

int FSTree::countSubdirsFast(const QString &root, int hardCap)
{
    // qDebug() << "FSTree::countSubdirsFast start (thread)" << QThread::currentThread();

    int count = 0;
    QStack<QString> stack;
    stack.push(root);

    while (!stack.isEmpty()) {
        if (G::stop || count > hardCap)
            break;

        const QString path = stack.pop();
        QDir dir(path);
        const QFileInfoList subdirs = dir.entryInfoList(QDir::Dirs | QDir::NoDotAndDotDot | QDir::NoSymLinks);

        for (const QFileInfo &fi : subdirs) {
            if (G::stop || ++count > hardCap)
                break;

            stack.push(fi.absoluteFilePath());
        }
    }

    // qDebug() << "FSTree::countSubdirsFast done, count =" << count;
    return count;
}

void FSTree::selectRecursively(QString folderPath, bool toggle)
{
    // qDebug() << "FSTree::selectRecursively start";

    if (watcherCount.isRunning()) {
        // qDebug() << "FSTree::selectRecursively already running, ignoring";
        return;
    }

    // Remember parameters so we can resume later
    pendingFolderPath = folderPath;
    pendingToggle = toggle;

    // disable heavy UI bits
    setShowImageCount(false);
    isSelectingFolders = true;
    G::stop = false;

    // qDebug() << "FSTree::selectRecursively starting async subdir count";
    startCountSubdirs(folderPath, maxExpandLimit);
}

// called automatically when countSubdirsFast finishes
void FSTree::onCountFinished(int recurseFoldersCount, bool wasCancelled)
{
    isSelectingFolders = false;

    if (wasCancelled) {
        qDebug() << "FSTree::onCountFinished cancelled";
        setShowImageCount(true);
        return;
    }

    // Too many subfolders: just select root folder and mark orange
    if (recurseFoldersCount >= maxExpandLimit) {
        QString step = "There are a lot of subfolders, this could take a minute.\n";
        QString escapeClause = "\nPress \"Esc\" to stop.";
        mw->setCentralMessage(step + escapeClause);
        qApp->processEvents();
        qDebug() << "Over limit â€” marking folder";
        fsModel->isMaxRecurse = true;
        fsModel->maxRecursedRoots.append(pendingFolderPath);
        markFolderOverLimit(pendingFolderPath, true);
        QPersistentModelIndex index = fsFilter->mapFromSource(fsModel->index(pendingFolderPath));
        selectionModel()->select(index, QItemSelectionModel::Select | QItemSelectionModel::Rows);
        setShowImageCount(true);
        return;
    }

    // Proceed to expansion and selection only if below limit
    // qDebug() << "Expanding recursively...";
    QStringList recursedFolders;
    recursedFolders.append(pendingFolderPath);

    QDirIterator it(pendingFolderPath, QDir::Dirs | QDir::NoDotAndDotDot | QDir::NoSymLinks,
                    QDirIterator::Subdirectories);
    while (it.hasNext()) {
        it.next();

        const QFileInfo fi = it.fileInfo();
        if (!fi.isDir()) continue;

        QString dPath = fi.absoluteFilePath();
        recursedFolders.append(dPath);
        QPersistentModelIndex index = fsFilter->mapFromSource(fsModel->index(dPath));
        selectionModel()->setCurrentIndex(index, QItemSelectionModel::NoUpdate);
    }

    for (const QString &path : recursedFolders) {

        QModelIndex index = fsFilter->mapFromSource(fsModel->index(path));
        if (pendingToggle)
            selectionModel()->select(index, QItemSelectionModel::Toggle | QItemSelectionModel::Rows);
        else
            selectionModel()->select(index, QItemSelectionModel::Select | QItemSelectionModel::Rows);
    }

    setShowImageCount(true);
    qDebug() << "FSTree::onCountFinished done";
}
