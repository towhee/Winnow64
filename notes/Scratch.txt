Stride is number of bytes per line.

init_CABAC_decoder
decode_slice_unit_sequential (appears to not be called by anything)
decode_slice_unit_frame_parallel
decode_image_frame_parallel
run_main_loop
thread_main_loop
main_loop_thread
start_decoding_thread
decoder_context::decoder_context (decctx.cc)

de265_decoder_context* ctx = de265_new_decoder();  (dec265.cc)
main (dec265.cc)

Steps to decode hevc:
CABAC

// Free a previously allocated HEIF context. You should not free a context twice.
LIBHEIF_API
void heif_context_free(struct heif_context*);

// Release image handle.
LIBHEIF_API
void heif_image_handle_release(const struct heif_image_handle*);

// Release heif_image.
LIBHEIF_API
void heif_image_release(const struct heif_image*);


LIBHEIF_API
int heif_image_handle_has_alpha_channel(const struct heif_image_handle*);

LIBHEIF_API
int heif_image_handle_get_luma_bits_per_pixel(const struct heif_image_handle*);

LIBHEIF_API
int heif_image_handle_get_chroma_bits_per_pixel(const struct heif_image_handle*);

// ------------------------- thumbnails -------------------------

// List the number of thumbnails assigned to this image handle. Usually 0 or 1.
LIBHEIF_API
int heif_image_handle_get_number_of_thumbnails(const struct heif_image_handle* handle);

LIBHEIF_API
int heif_image_handle_get_list_of_thumbnail_IDs(const struct heif_image_handle* handle,
                                                heif_item_id* ids, int count);

// Get the image handle of a thumbnail image.
LIBHEIF_API
struct heif_error heif_image_handle_get_thumbnail(const struct heif_image_handle* main_image_handle,
                                                  heif_item_id thumbnail_id,
                                                  struct heif_image_handle** out_thumbnail_handle);

// ------------------------- metadata (Exif / XMP) -------------------------

// How many metadata blocks are attached to an image. Usually, the only metadata is
// an "Exif" block.
LIBHEIF_API
int heif_image_handle_get_number_of_metadata_blocks(const struct heif_image_handle* handle,
                                                    const char* type_filter);

// 'type_filter' can be used to get only metadata of specific types, like "Exif".
// If 'type_filter' is NULL, it will return all types of metadata IDs.
LIBHEIF_API
int heif_image_handle_get_list_of_metadata_block_IDs(const struct heif_image_handle* handle,
                                                     const char* type_filter,
                                                     heif_item_id* ids, int count);

// Return a string indicating the type of the metadata, as specified in the HEIF file.
// Exif data will have the type string "Exif".
// This string will be valid until the next call to a libheif function.
// You do not have to free this string.
LIBHEIF_API
const char* heif_image_handle_get_metadata_type(const struct heif_image_handle* handle,
                                                heif_item_id metadata_id);

LIBHEIF_API
const char* heif_image_handle_get_metadata_content_type(const struct heif_image_handle* handle,
                                                        heif_item_id metadata_id);

// Get the size of the raw metadata, as stored in the HEIF file.
LIBHEIF_API
size_t heif_image_handle_get_metadata_size(const struct heif_image_handle* handle,
                                           heif_item_id metadata_id);

// 'out_data' must point to a memory area of the size reported by heif_image_handle_get_metadata_size().
// The data is returned exactly as stored in the HEIF file.
// For Exif data, you probably have to skip the first four bytes of the data, since they
// indicate the offset to the start of the TIFF header of the Exif data.
LIBHEIF_API
struct heif_error heif_image_handle_get_metadata(const struct heif_image_handle* handle,
                                                 heif_item_id metadata_id,
                                                 void* out_data);


"  4,839,492,000"   "CompareView::enterEvent..........................."   ""
"         61,800"   "CompareView::select..............................."   ""
"        131,800"   "CompareImages::deselectAll........................"   ""
"        162,400"   "CompareView::deselect............................."   ""
"      1,523,600"   "CompareView::deselect............................."   ""
"      1,364,300"   "CompareView::deselect............................."   ""
"      2,272,800"   "CompareView::deselect............................."   ""
"      2,752,600"   "CompareImages::zoomChangeFromView................."   ""
CompareImages::zoomChangeFromView zoomValue = 0.171087
"        134,100"   "MW::updateStatus.................................."   ""
"         60,700"   "IconView::getCurrentFilePath......................"   ""
"         54,900"   "Win::availableMemory.............................."   ""
"         40,100"   "MW::getZoom......................................."   ""
"         40,600"   "MW::getPosition..................................."   ""
"         32,000"   "IconView::getSelectedCount........................"   ""
"         70,600"   "MW::getPicked....................................."   ""
"         55,500"   "MW::updateStatusBar..............................."   ""
"        243,900"   "Filters::isAnyFilter.............................."   ""
"        679,500"   "MW::updateProgressBarWidth........................"   ""
"         36,000"   "MW::availableSpaceForProgressBar.................."   ""
"        151,300"   "MW::getPosition..................................."   ""
"         39,100"   "MW::getZoom......................................."   ""
"         42,900"   "MW::metadataChanged..............................."   ""
"         87,800"   "InfoView::showOrHide.............................."   ""
"         49,400"   "MW::getSelectedFileSize..........................."   ""
"         39,200"   "MW::memoryReqdForSelection........................"   ""
"         36,300"   "MW::getPicked....................................."   ""

    QElapsedTimer profileTimer; profileTimer.restart();
    {
    #ifdef ISPROFILE
    profileTimer.restart();
    #endif
    }
    {
    #ifdef ISPROFILE
    G::t.elapsed();
    #endif
    }
