My Qt and c++ app, Winnow, reads the images in a folder.
It uses a class DataModel : public QStandardItemModel to keep track of information about each image in the folder.
It uses class ImageCache : public QThread to cache a QImage for each image into QHash<QString, QImage> imCache.
In the main gui thread the user can traverse thumbnails of each image in the folder.
As the position changes in the folder, it is sent to ImageCache::setCurrentPosition.
ImageCache::setTargetRange limits the size of imCache to maxSize, caching the images closest to the current position in a priority order.

ImageCache structures to keep track of what to cache next:
    int key; // the datamodel row for the image
    enum Status {NotCached, Caching, Cached};
    struct CacheStatus {
        Status status;
        int decoderId;
        int instance;
    };
    QList<int> toCache;
    QHash<int,CacheStatus> toCacheStatus;

imagecache.h
    private:
        QThread imageCacheThread;  // Separate thread for ImageCache


ImageCache constructor:
ImageCache::ImageCache(ImageCacheData *icd, DataModel *dm) : QObject(nullptr)
{
    moveToThread(&imageCacheThread);

    // data is kept in ImageCacheData icd, a hash table
    this->icd = icd;
    this->dm = dm;
    // new metadata to avoid thread collisions?
    metadata = new Metadata;

    // create n decoder threads
    for (int id = 0; id < QThread::idealThreadCount(); ++id) {
        ImageDecoder *decoder = new ImageDecoder(id, dm, metadata);
        QThread *thread = new QThread;

        decoder->moveToThread(thread);
        connect(decoder, &ImageDecoder::done, this, &ImageCache::fillCache);
        connect(this, &ImageCache::stopDecoders, decoder, &ImageDecoder::stop);

        thread->start();
        decoders.append(decoder);
    }
}

class ImageDecoder : public QThread creates a QImage from an image file.
ImageDecoder::ImageDecoder(int id,
                           DataModel *dm,
                           Metadata *metadata)
    : QObject(nullptr)
{
    threadId = id;
    status = Status::Ready;
    fPath = "";
    sfRow = -1;
    instance = 0;
    this->dm = dm;
    this->metadata = metadata;
}

void ImageDecoder::decode(int row, int instance)
{
    sfRow = row ;
    status = Status::Busy;
    fPath = dm->sf->index(sfRow,0).data(G::PathRole).toString();
    this->instance = instance;
    errMsg = "";

    // decode
    if (load()) {
        if (metadata->rotateFormats.contains(ext) && !abort) rotate();
        if (G::colorManage && !abort) colorManage();
        if (image.isNull()) status = Status::Failed;
        else status = Status::Success;
    }

// signal back to ImageCache::fillCache with QImage
    if (!abort) emit done(threadId);
}

ImageCache::setCurrentPosition calls ImageCache::dispatch().
ImageCache::launchDecoders calls ImageCache::fillCache for each ImageDecoder.
ImageCache::fillCache checks the ImageDecoder, and if it has a QImage it inserts it into imCache and removes it from toCache and toCacheStatus.
ImageCache::fillCache then gets the next image from toCache and sends it to the ImageDecoder::decode().
Each ImageDecoder signals ImageCache::fillCache with the QImage when it is done.
The ImageCache::fillCache / ImageDecoder cycle continues until toCache is empty.

void ImageCache::setCurrentPosition(QString fPath, QString src)
{
    key = dm->proxyRowFromPath(fPath);
    dispatch();
}

void ImageCache::dispatch()
{
    setTargetRange();
    launchDecoders();
}

void ImageCache::stop(QString src)
{
if (isRunning()) {
    gMutex.lock();
    abort = true;
    condition.wakeOne();
    quit();
    gMutex.unlock();

    // Stop all decoder threads first
    for (int id = 0; id < decoderCount; ++id) {
        decoder[id]->stop();
    }
}

void ImageCache::launchDecoders(QString src)
{
    for (int id = 0; id < decoderCount; ++id) {
        if (decoder[id]->isRunning()) continue;
        fillCache(id);
    }
}

void ImageCache::fillCache(int id)
{
    int cacheKey = decoder[id]->sfRow;  // = -1 if not a returning decoder
    if (cacheKey != -1) {
        cacheImage(id, cacheKey);
    }
    bool isNextToCache = toCacheKey != -1;
    bool isCacheKeyOk = isValidKey(toCacheKey);
    bool okDecodeNextImage = !abort && isNextToCache && isCacheKeyOk;
    // reun decoder for the next image to decode into a QImage
    if (okDecodeNextImage) decodeNextImage(id, toCacheKey);
    // if no decoders running then we are finished
    if (allDecodersReady()) abort = true;
}

void ImageCache::decodeNextImage(int id, int sfRow)
{
    QMetaObject::invokeMethod(decoders[id], "decode", Qt::QueuedConnection,
                              Q_ARG(int, sfRow), Q_ARG(int, instance));
}

My gui is MW::mw (subclassing QMainWindow).

void MW::createImageCache()
{
    imageCache = new ImageCache(this, icd, dm);

    // Signal to ImageCache new image selection
    connect(this, &MW::setImageCachePosition,
            imageCache, &ImageCache::setCurrentPosition);
}

Does the above code seem like it will work. How do I manage this from mw to keep the
imageCacheThread and all the ImageDecoder threads running, but idle when the abort flag
is set to true.  I need the code for function start() in ImageCache.
