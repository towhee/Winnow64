

void ImageCache::setTargetRange(int key)
{
    if (debugLog || G::isLogger)
        log("setTargetRange", "row = " + QVariant(key).toString());

    if (abort) return;

    const int n = dm->sf->rowCount();
    if (n <= 0 || key < 0 || key >= n) return;

    float sumMB = 0.0f;
    int nearestToTarget = -1;

    // If folders changed, reset target queues
    if (instance != dm->instance) {
        toCache.clear();
        toCacheStatus.clear();
        instance = dm->instance;
    }

    // Direction helpers
    const int dir = isForward ? +1 : -1;

    // Forward phase aims for ~2/3 of capacity
    const float forwardCap = maxMB * (2.0f / 3.0f);

    // Positions: ahead starts at key, behind starts one step opposite
    int aheadPos  = key;
    int behindPos = key - dir;   // if dir=+1 -> key-1; if dir=-1 -> key+1

    auto addToQueue = [&](int pos) {
        if (abort) return;

        // Videos: mark cached; do not count toward sumMB
        if (dm->valueSf(pos, G::VideoColumn).toBool()) {
            emit setCached(pos, true, instance);
            (pos < key) ? targetFirst = pos : targetLast = pos;
            return;
        }

        const float szMB = dm->sf->index(pos, G::CacheSizeColumn).data().toFloat();

        // Only count/queue if we still have room
        if (sumMB + szMB < maxMB) {
            const QString fPath = dm->valueSf(pos, 0, G::PathRole).toString();
            // If not already queued to cache, then add to queue
            if (!toCache.contains(pos) && !icd->contains(fPath)) {
                toCacheAppend(pos);
            }
            // Get pressure on cache
            if (toCache.contains(pos) && nearestToTarget == -1) {
                nearestToTarget = pos;
                int pressure = qAbs(nearestToTarget - key);
            }
            sumMB += szMB;
            (pos < key) ? targetFirst = pos : targetLast = pos;
        }
    };

    // Fill forward up to ~2/3 capacity
    while (!abort && sumMB < forwardCap) {
        if (aheadPos < 0 || aheadPos >= n) break;
        addToQueue(aheadPos);
        aheadPos += dir;
    }

    // Fill behind until total reaches maxMB
    while (!abort && sumMB < maxMB) {
        if (behindPos < 0 || behindPos >= n) break;
        addToQueue(behindPos);
        behindPos -= dir;
    }

    // Fill forward again if still not full
    while (!abort && sumMB < maxMB) {
        if (aheadPos < 0 || aheadPos >= n) break;
        addToQueue(aheadPos);
        aheadPos += dir;
    }
}
