Gulp 1

global.h
namespace G
{
    enum UserRoles {
        PathRole = Qt::UserRole + 1,    // path to image file
        IconRectRole,                   // used in IconView
        // CachedRole,                     // used in ImageView, IconViewDelegate
        DupIsJpgRole,                   // manage raw/jpg pairs
        DupOtherIdxRole,                // manage raw/jpg pairs
        DupHideRawRole,                 // manage raw/jpg pairs
        DupRawTypeRole,                 // manage raw/jpg pairs
        ColumnRole,                     // used by Filters
        GeekRole                        // used in TableView display of columns
    };

    enum dataModelColumns {
        // items available for TableView in order
        // items read when new folder (core fields)
        PathColumn,
        RowNumberColumn,
        NameColumn,
        ... many more rows
    }
    extern bool stop;
    extern bool isInitializing;
    extern bool allMetadataLoaded;
    extern bool iconChunkLoaded;
    extern int dmInstance;
}

global.cpp
#include "Main/global.h"

namespace G
{
    bool stop = false;
    bool isInitializing;
    bool allMetadataLoaded;         // all metadata attempted
    bool iconChunkLoaded;           // all icon chunk loaded
    int dmInstance;                 // DataModel instance


} // end NameSpace G

FSTree snippet used to select folders to load
class FSTree : public QTreeView

void FSTree::mousePressEvent(QMouseEvent *event)
{
    static QModelIndex prevIdx = QModelIndex();

    QModelIndex index = indexAt(event->pos());
    if (!index.isValid()) return;

    QModelIndex idx0 = index.sibling(index.row(), 0);
    QString dPath = idx0.data(QFileSystemModel::FilePathRole).toString();
    bool recurse = false;
    bool resetDataModel = false;
    bool isAlt = event->modifiers() & Qt::AltModifier;
    bool isCtrl = event->modifiers() & Qt::ControlModifier;
    bool isShift = event->modifiers() & Qt::ShiftModifier;
    bool isMeta = event->modifiers() & Qt::MetaModifier;
    bool isNoModifier = event->modifiers() == Qt::NoModifier;

    if (isMeta) return;

    // New selection (primary folder)
    if (isNoModifier) {
        QTreeView::mousePressEvent(event);
        resetDataModel = true;
        recurse = false;
        emit folderSelectionChange(dPath, "Add", resetDataModel, recurse);
        prevIdx = index;
        return;
    }

    // recurse load all subfolders images
    if (isAlt && !isShift) {
        if (isCtrl) {
            resetDataModel = false;
            recurse = true;
            emit folderSelectionChange(dPath, "Toggle", resetDataModel, recurse);
            bool toggle = true;
            selectRecursively(dPath, toggle);
            prevIdx = index;
            return;
        }
        resetDataModel = true;
        recurse = true;
        emit folderSelectionChange(dPath, "Add", resetDataModel, recurse);
        selectionModel()->clearSelection();
        selectRecursively(dPath);
        return;
    }

    // toggle folder
    if (isCtrl) {
        int folders = selectedFolderPaths().count();
        bool folderWasSelected = selectedFolderPaths().contains(dPath);
        resetDataModel = false;
        recurse = false;
        if (folderWasSelected) {
            if (folders < 2) return;
            emit folderSelectionChange(dPath, "Remove", resetDataModel, recurse);
        }
        else {
            emit folderSelectionChange(dPath, "Add", resetDataModel, recurse);
        }
        QModelIndex index = fsFilter->mapFromSource(fsModel->index(dPath));
        selectionModel()->select(index, QItemSelectionModel::Toggle | QItemSelectionModel::Rows);
        prevIdx = index;
        return;
    }

    // Select visible unselected between previous selected folder to idx0
    if (isShift) {
        if (!prevIdx.isValid()) {
                QModelIndexList selectedIndexes = selectionModel()->selectedIndexes();
            if (!selectedIndexes.isEmpty()) {
                prevIdx = selectedIndexes.first();
            } else {
                prevIdx = indexAt(QPoint(0, 0));
            }
        }
        recurse = false;
        if (isAlt) recurse = true;
        QStringList foldersToAdd = selectVisibleBetween(prevIdx, idx0, recurse);
        foreach(QString path, foldersToAdd) {
            resetDataModel = false;
            emit folderSelectionChange(path, "Add", resetDataModel, recurse);
            QModelIndex index = fsFilter->mapFromSource(fsModel->index(dPath));
            selectionModel()->select(index, QItemSelectionModel::Select | QItemSelectionModel::Rows);
        }
        prevIdx = index;
    }
}

mainwindow.h
class MW : public QMainWindow
{
    Q_OBJECT
public:
    FSTree(QWidget *parent, DataModel *dm, Metadata *metadata);
}

mainwindow.cpp
MW::initialize() {
    connect(fsTree, &FSTree::folderSelectionChange, this, &MW::folderSelectionChange);

}

void MW::folderSelectionChange(QString folderPath, QString op, bool resetDataModel, bool recurse)
{
    G::allMetadataLoaded = false;
    G::iconChunkLoaded = false;
    G::isModifyingDatamodel = true;
    if (resetDataModel) {
        stop(fun + " reset DataModel");
        reset(fun);
        dm->newInstance();
    }
    else {
        buildFilters->abortIfRunning();
    }
    dm->enqueueFolderSelection(folderPath, op, recurse);
}

bool MW::stop(QString src)
{
    if (G::stop && !G::removingFolderFromDM) return false;
    G::stop = true;
    dm->abort = true;

    metaRead->abortReaders();
    imageCache->abortProcessing();
    buildFilters->abortIfRunning();

    G::stop = false;
    G::removingFolderFromDM = false;

    return true;
}

void MW::reset(QString src)
{
    buildFilters->stop();

    G::allMetadataLoaded = false;
    G::iconChunkLoaded = false;

    setWindowTitle(winnowWithVersion);
    infoView->clearInfo();
    updateDisplayResolution();
    isDragDrop = false;

    cacheProgressBar->clearImageCacheProgress();
    progressLabel->setVisible(false);
    filterStatusLabel->setVisible(false);
    updateClassification();
    thumbView->setUpdatesEnabled(false);
    gridView->setUpdatesEnabled(false);
    tableView->setUpdatesEnabled(false);
    tableView->setSortingEnabled(false);
    thumbView->setUpdatesEnabled(true);
    gridView->setUpdatesEnabled(true);
    tableView->setUpdatesEnabled(true);
    tableView->setSortingEnabled(true);
    imageView->clear();
    imageView->isFirstImageNewInstance = true;
    dm->selectionModel->clear();
    dm->currentSfRow = 0;
    dm->clearDataModel();
    icd->clear();
}

Gulp 2 ----------------------------------------------------------------------------------

MW::initialize() {
    connect(dm, &DataModel::folderChange, this, &MW::folderChanged);

}

void DataModel::enqueueOp(const QString folderPath, const QString op)
{
    if (op == "Add") {
        if (!folderList.contains(folderPath)) {
            folderQueue.enqueue(qMakePair(folderPath, true));
        }
    }

    if (op == "Remove") {
        if (folderList.contains(folderPath)) {
            folderQueue.enqueue(qMakePair(folderPath, false));
        }
    }

    if (op == "Toggle") {
        if (folderList.contains(folderPath)) {
            folderQueue.enqueue(qMakePair(folderPath, false));
        }
        else folderQueue.enqueue(qMakePair(folderPath, true));
    }
}

void DataModel::enqueueFolderSelection(const QString &folderPath, QString op, bool recurse)
{
    if (recurse) {
        enqueueOp(folderPath, op);
        QDirIterator it(folderPath, QDirIterator::Subdirectories);
        while (it.hasNext()) {
            QString dPath = it.next();
            if (it.fileInfo().isDir() && it.fileName() != "." && it.fileName() != "..") {
                enqueueOp(dPath, op);
            }
        }
    }
    else {
        enqueueOp(folderPath, op);
    }

    // If not already processing, start the processing
    if (!isProcessingFolders) {
        isProcessingFolders = true;
        processNextFolder();
    }
}

void DataModel::processNextFolder()
{
    if (folderQueue.isEmpty()) {
        isProcessingFolders = false;
        isProcessingFolders = false;
        emit folderChange();
        return;
    }

    if (G::stop) return;

    QPair<QString, bool> folderOperation = folderQueue.dequeue();
    QString folderPath = folderOperation.first;
    bool addFolderImages = folderOperation.second;

    if (addFolderImages) {
        addFolder(folderPath);
    }

    else {
        removeFolder(folderPath);
    }

    processNextFolder();
}

Gulp 3 --------------------------------------------------------------------------------

void DataModel::addFolder(const QString &folderPath)
{
    QMutexLocker locker(&mutex);
    abort = false;

    folderList.append(folderPath);
    loadingModel = true;
    locker.unlock();

    QDir dir(folderPath);
    dir.setNameFilters(*fileFilters);
    dir.setFilter(QDir::Files);
    QList<QFileInfo> folderFileInfoList = dir.entryInfoList();

    if (combineRawJpg) {
        // make sure, if raw+jpg pair, that raw file is first to make combining easier
        std::sort(folderFileInfoList.begin(), folderFileInfoList.end(), lessThanCombineRawJpg);
    }
    else {
        std::sort(folderFileInfoList.begin(), folderFileInfoList.end(), lessThan);
    }

    QString step = "Loading eligible image file information.<br>";
    QString escapeClause = "Press \"Esc\" to stop.";

    // test if raw file to match jpg when same file names and one is a jpg
    QString suffix;
    QString prevRawSuffix = "";
    QString prevRawBaseName = "";
    QString baseName = "";
    QModelIndex prevRawIdx;

    int row = rowCount();
    int oldRowCount = rowCount();
    int newRowCount = oldRowCount;

    int counter = 0;
    int countInterval = 100;
    for (const QFileInfo &fileInfo : folderFileInfoList) {
        if (abort) return;
        QString fPath = fileInfo.filePath();
        if (fPathRowContains(fPath)) continue;

        if (fileInfo.size() == 0) {
            continue;
        }

        setRowCount(row + 1);
        if (!columnCount()) setColumnCount(G::TotalColumns);
        addFileDataForRow(row, fileInfo);

        if (row % countInterval == 0 && row > 0) updateLoadStatus(newRowCount);

        QString suffix = fileInfo.suffix().toLower();
        QString baseName = fileInfo.completeBaseName();
        if (metadata->hasJpg.contains(suffix)) {
            prevRawSuffix = suffix;
            prevRawBaseName = fileInfo.completeBaseName();
            prevRawIdx = index(row, 0);
        }

        QMutexLocker locker(&mutex);
        if ((suffix == "jpg" || suffix == "jpeg") && baseName == prevRawBaseName) {
            setData(prevRawIdx, true, G::DupHideRawRole);
            setData(prevRawIdx, index(row, 0), G::DupOtherIdxRole);
            setData(index(row, 0), prevRawIdx, G::DupOtherIdxRole);
            setData(index(row, 0), true, G::DupIsJpgRole);
            setData(index(row, 0), prevRawSuffix.toUpper(), G::DupRawTypeRole);
            if (combineRawJpg)
                setData(index(row, G::TypeColumn), "JPG+" + prevRawSuffix.toUpper());
            else
                setData(index(row, G::TypeColumn), "JPG");
        }
        row++;
    }

    newRowCount = row;

    if (oldRowCount == 0 && newRowCount > 0) {
        firstFolderPathWithImages = folderPath;
        setCurrent(index(0, 0), instance);
    }

    if (newRowCount > hugeIconThreshold) {
        iconChunkSize = 100;
    }

    if (folderQueue.isEmpty()) {
        endLoad(true);
    }
}

void DataModel::removeFolder(const QString &folderPath)
{
    folderList.removeAll(folderPath);
    QModelIndex par = QModelIndex();

    for (int row = rowCount() - 1; row >= 0; row--) {
        QString filePath = index(row, 0).data(G::PathRole).toString();
        QFileInfo info(filePath);
        QString rowFolder = info.dir().absolutePath();
        if (rowFolder == folderPath) {
            beginRemoveRows(par, row, row);
            removeRows(row, 1);
            endRemoveRows();
        }
    }
    sf->invalidate();

    rebuildRowFromPathHash();

    setCurrent(currentFilePath, instance);
}

bool DataModel::endLoad(bool success)
{
    loadingModel = false;
    sf->suspend(false);
    if (success) {
        checkChunkSize = iconChunkSize > rowCount();
        return true;
    }
    else {
        clear();
        filters->loadingDataModelFailed();
        return false;
    }
}

Gulp 4 -------------------------------------------------------------------------------

void DataModel::addFileDataForRow(int row, QFileInfo fileInfo)
{
    QString fPath = fileInfo.filePath();
    QString folderName = fileInfo.dir().dirName();
    QString ext = fileInfo.suffix().toLower();
    if (fPathRow.contains(fPath)) return;
    fPathRowSet(fPath, row);
    QString search = fPath;
    setData(index(row, G::RowNumberColumn), row + 1);
    setData(index(row, G::RowNumberColumn), int(Qt::AlignCenter | Qt::AlignVCenter), Qt::TextAlignmentRole);
    setData(index(row, G::PathColumn), fPath, G::PathRole);
    setData(index(row, G::PathColumn), QRect(), G::IconRectRole);
    setData(index(row, G::PathColumn), false, G::DupHideRawRole);
    setData(index(row, G::NameColumn), fileInfo.fileName());
    setData(index(row, G::NameColumn), fileInfo.fileName(), Qt::ToolTipRole);
    setData(index(row, G::FolderNameColumn), folderName);
    setData(index(row, G::TypeColumn), fileInfo.suffix().toUpper());
    QString s = fileInfo.suffix().toUpper();
    setData(index(row, G::VideoColumn), metadata->videoFormats.contains(ext));
    setData(index(row, G::VideoColumn), int(Qt::AlignCenter | Qt::AlignVCenter), Qt::TextAlignmentRole);
    uint p = static_cast<uint>(fileInfo.permissions());
    setData(index(row, G::PermissionsColumn), p);
    setData(index(row, G::PermissionsColumn), int(Qt::AlignCenter | Qt::AlignVCenter), Qt::TextAlignmentRole);
    bool isReadWrite = (p & QFileDevice::ReadUser) && (p & QFileDevice::WriteUser);
    setData(index(row, G::ReadWriteColumn), isReadWrite);
    setData(index(row, G::ReadWriteColumn), int(Qt::AlignCenter | Qt::AlignVCenter), Qt::TextAlignmentRole);
    setData(index(row, G::TypeColumn), s);
    setData(index(row, G::TypeColumn), int(Qt::AlignCenter), Qt::TextAlignmentRole);
    quint32 bytes = fileInfo.size();
    setData(index(row, G::SizeColumn), bytes);
    setData(index(row, G::SizeColumn), int(Qt::AlignRight | Qt::AlignVCenter), Qt::TextAlignmentRole);
    float mb = static_cast<double>(bytes) / (1 << 20);
    if (raw.contains(ext)) mb *= 3.5;
    if (ext == "jpg" || ext == "jpeg") mb *= 15;
    setData(index(row, G::CacheSizeColumn), mb);
    setData(index(row, G::CompareColumn), false);
    s = fileInfo.birthTime().toString("yyyy-MM-dd hh:mm:ss.zzz");
    setData(index(row, G::CreatedColumn), s);
    s = fileInfo.lastModified().toString("yyyy-MM-dd hh:mm:ss");
    search += s;
    setData(index(row, G::ModifiedColumn), s);
    setData(index(row, G::PickColumn), "Unpicked");
    setData(index(row, G::PickColumn), int(Qt::AlignCenter | Qt::AlignVCenter), Qt::TextAlignmentRole);
    setData(index(row, G::IngestedColumn), "false");
    setData(index(row, G::IngestedColumn), int(Qt::AlignCenter | Qt::AlignVCenter), Qt::TextAlignmentRole);
    setData(index(row, G::MetadataReadingColumn), false);
    setData(index(row, G::MetadataAttemptedColumn), false);
    setData(index(row, G::MetadataLoadedColumn), false);
    setData(index(row, G::IconLoadedColumn), false);
    setData(index(row, G::SearchColumn), "false");
    setData(index(row, G::SearchColumn), Qt::AlignLeft, Qt::TextAlignmentRole);
    setData(index(row, G::SearchTextColumn), search);
    setData(index(row, G::SearchTextColumn), search, Qt::ToolTipRole);
}

Class DataModel : public QStandardItemModel

DataModel::DataModel(QObject *parent,
Metadata *metadata,
Filters *filters,
bool &combineRawJpg) :

QStandardItemModel(parent),
combineRawJpg(combineRawJpg)
{
    instance = -1;
    this->metadata = metadata;
    this->filters = filters;

    setModelProperties();

    sf = new SortFilter(this, filters, combineRawJpg);
    sf->setSourceModel(this);
    selectionModel = new QItemSelectionModel(sf);

    dir = new QDir();

    fileFilters = new QStringList;
    foreach (const QString &str, metadata->supportedFormats) {
        fileFilters->append("*." + str);
    }

    emptyImg.load(":/images/no_image.png");
    setThumbnailLegend();

    iconChunkSize = G::maxIconChunk;
    defaultIconChunkSize = G::maxIconChunk;
}

void DataModel::setModelProperties()
{
    setSortRole(Qt::EditRole);

    setHorizontalHeaderItem(G::PathColumn, new QStandardItem("Icon")); horizontalHeaderItem(G::PathColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::RowNumberColumn, new QStandardItem("#")); horizontalHeaderItem(G::RowNumberColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::NameColumn, new QStandardItem("File Name")); horizontalHeaderItem(G::NameColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::FolderNameColumn, new QStandardItem("Folder Name")); horizontalHeaderItem(G::NameColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::MSToReadColumn, new QStandardItem("Read ms")); horizontalHeaderItem(G::MSToReadColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::PickColumn, new QStandardItem("Pick")); horizontalHeaderItem(G::PickColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::IngestedColumn, new QStandardItem("Ingested")); horizontalHeaderItem(G::IngestedColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::LabelColumn, new QStandardItem("Colour")); horizontalHeaderItem(G::LabelColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::RatingColumn, new QStandardItem("Rating")); horizontalHeaderItem(G::RatingColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::SearchColumn, new QStandardItem("Search")); horizontalHeaderItem(G::SearchColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::TypeColumn, new QStandardItem("Type")); horizontalHeaderItem(G::TypeColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::VideoColumn, new QStandardItem("Video")); horizontalHeaderItem(G::VideoColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::ApertureColumn, new QStandardItem("Aperture")); horizontalHeaderItem(G::ApertureColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::ShutterspeedColumn, new QStandardItem("Shutter")); horizontalHeaderItem(G::ShutterspeedColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::ISOColumn, new QStandardItem("ISO")); horizontalHeaderItem(G::ISOColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::ExposureCompensationColumn, new QStandardItem("  EC  ")); horizontalHeaderItem(G::ExposureCompensationColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::DurationColumn, new QStandardItem("Duration")); horizontalHeaderItem(G::DurationColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::CameraMakeColumn, new QStandardItem("Make")); horizontalHeaderItem(G::CameraMakeColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::CameraModelColumn, new QStandardItem("Model")); horizontalHeaderItem(G::CameraModelColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::LensColumn, new QStandardItem("Lens")); horizontalHeaderItem(G::LensColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::FocalLengthColumn, new QStandardItem("Focal length")); horizontalHeaderItem(G::FocalLengthColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::FocusXColumn, new QStandardItem("FocusX")); horizontalHeaderItem(G::FocusXColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::FocusYColumn, new QStandardItem("FocusY")); horizontalHeaderItem(G::FocusYColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::GPSCoordColumn, new QStandardItem("GPS Coord")); horizontalHeaderItem(G::GPSCoordColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::SizeColumn, new QStandardItem("Size")); horizontalHeaderItem(G::SizeColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::WidthColumn, new QStandardItem("Width")); horizontalHeaderItem(G::WidthColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::HeightColumn, new QStandardItem("Height")); horizontalHeaderItem(G::HeightColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::ModifiedColumn, new QStandardItem("Last Modified")); horizontalHeaderItem(G::ModifiedColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::CreatedColumn, new QStandardItem("Created")); horizontalHeaderItem(G::CreatedColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::YearColumn, new QStandardItem("Year")); horizontalHeaderItem(G::YearColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::DayColumn, new QStandardItem("Day")); horizontalHeaderItem(G::DayColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::CreatorColumn, new QStandardItem("Creator")); horizontalHeaderItem(G::CreatorColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::MegaPixelsColumn, new QStandardItem("MPix")); horizontalHeaderItem(G::MegaPixelsColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::LoadMsecPerMpColumn, new QStandardItem("Msec/Mp")); horizontalHeaderItem(G::LoadMsecPerMpColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::DimensionsColumn, new QStandardItem("Dimensions")); horizontalHeaderItem(G::DimensionsColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::AspectRatioColumn, new QStandardItem("Aspect Ratio")); horizontalHeaderItem(G::AspectRatioColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::OrientationColumn, new QStandardItem("Orientation")); horizontalHeaderItem(G::OrientationColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::RotationColumn, new QStandardItem("Rot")); horizontalHeaderItem(G::RotationColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::CopyrightColumn, new QStandardItem("Copyright")); horizontalHeaderItem(G::CopyrightColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::TitleColumn, new QStandardItem("Title")); horizontalHeaderItem(G::TitleColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::EmailColumn, new QStandardItem("Email")); horizontalHeaderItem(G::EmailColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::UrlColumn, new QStandardItem("Url")); horizontalHeaderItem(G::UrlColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::KeywordsColumn, new QStandardItem("Keywords")); horizontalHeaderItem(G::KeywordsColumn)->setData(false, G::GeekRole);
    setHorizontalHeaderItem(G::MetadataReadingColumn, new QStandardItem("Meta Reading")); horizontalHeaderItem(G::MetadataReadingColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::MetadataAttemptedColumn, new QStandardItem("Meta Attempted")); horizontalHeaderItem(G::MetadataAttemptedColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::MetadataLoadedColumn, new QStandardItem("Meta Loaded")); horizontalHeaderItem(G::MetadataLoadedColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::IconLoadedColumn, new QStandardItem("Icon Loaded")); horizontalHeaderItem(G::IconLoadedColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::MissingThumbColumn, new QStandardItem("Missing Thumb")); horizontalHeaderItem(G::MissingThumbColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::CompareColumn, new QStandardItem("Compare")); horizontalHeaderItem(G::CompareColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::_RatingColumn, new QStandardItem("_Rating")); horizontalHeaderItem(G::_RatingColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::_LabelColumn, new QStandardItem("_Label")); horizontalHeaderItem(G::_LabelColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::_CreatorColumn, new QStandardItem("_Creator")); horizontalHeaderItem(G::_CreatorColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::_TitleColumn, new QStandardItem("_Title")); horizontalHeaderItem(G::_TitleColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::_CopyrightColumn, new QStandardItem("_Copyright")); horizontalHeaderItem(G::_CopyrightColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::_EmailColumn, new QStandardItem("_Email")); horizontalHeaderItem(G::_EmailColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::_UrlColumn, new QStandardItem("_Url")); horizontalHeaderItem(G::_UrlColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::PermissionsColumn, new QStandardItem("Permissions")); horizontalHeaderItem(G::PermissionsColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::ReadWriteColumn, new QStandardItem("R/W")); horizontalHeaderItem(G::ReadWriteColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::OffsetFullColumn, new QStandardItem("OffsetFull")); horizontalHeaderItem(G::OffsetFullColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::LengthFullColumn, new QStandardItem("LengthFull")); horizontalHeaderItem(G::LengthFullColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::WidthPreviewColumn, new QStandardItem("WidthPreview")); horizontalHeaderItem(G::WidthPreviewColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::HeightPreviewColumn, new QStandardItem("HeightPreview")); horizontalHeaderItem(G::HeightPreviewColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::OffsetThumbColumn, new QStandardItem("OffsetThumb")); horizontalHeaderItem(G::OffsetThumbColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::LengthThumbColumn, new QStandardItem("LengthThumb")); horizontalHeaderItem(G::LengthThumbColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::samplesPerPixelColumn, new QStandardItem("samplesPerPixelFull")); horizontalHeaderItem(G::samplesPerPixelColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::isBigEndianColumn, new QStandardItem("isBigEndian")); horizontalHeaderItem(G::isBigEndianColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::ifd0OffsetColumn, new QStandardItem("ifd0Offset")); horizontalHeaderItem(G::ifd0OffsetColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::ifdOffsetsColumn, new QStandardItem("ifd0Offsets")); horizontalHeaderItem(G::ifdOffsetsColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::XmpSegmentOffsetColumn, new QStandardItem("XmpSegmentOffset")); horizontalHeaderItem(G::XmpSegmentOffsetColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::XmpSegmentLengthColumn, new QStandardItem("XmpSegmentLengthColumn")); horizontalHeaderItem(G::XmpSegmentLengthColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::IsXMPColumn, new QStandardItem("IsXMP")); horizontalHeaderItem(G::IsXMPColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::ICCSegmentOffsetColumn, new QStandardItem("ICCSegmentOffsetColumn")); horizontalHeaderItem(G::ICCSegmentOffsetColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::ICCSegmentLengthColumn, new QStandardItem("ICCSegmentLengthColumn")); horizontalHeaderItem(G::ICCSegmentLengthColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::ICCBufColumn, new QStandardItem("ICCBuf")); horizontalHeaderItem(G::ICCBufColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::ICCSpaceColumn, new QStandardItem("ICCSpace")); horizontalHeaderItem(G::ICCSpaceColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::CacheSizeColumn, new QStandardItem("CacheSize")); horizontalHeaderItem(G::CacheSizeColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::IsCachingColumn, new QStandardItem("IsCaching")); horizontalHeaderItem(G::IsCachingColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::IsCachedColumn, new QStandardItem("IsCached")); horizontalHeaderItem(G::IsCachedColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::AttemptsColumn, new QStandardItem("Attempts")); horizontalHeaderItem(G::AttemptsColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::DecoderIdColumn, new QStandardItem("DecoderId")); horizontalHeaderItem(G::DecoderIdColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::DecoderReturnStatusColumn, new QStandardItem("DecoderReturnStatus")); horizontalHeaderItem(G::DecoderReturnStatusColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::DecoderErrMsgColumn, new QStandardItem("Decoder Err Msg")); horizontalHeaderItem(G::DecoderErrMsgColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::OrientationOffsetColumn, new QStandardItem("OrientationOffset")); horizontalHeaderItem(G::OrientationOffsetColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::RotationDegreesColumn, new QStandardItem("RotationDegrees")); horizontalHeaderItem(G::RotationDegreesColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::IconSymbolColumn, new QStandardItem("IconSymbolColumn")); //horizontalHeaderItem(G::IconSymbolColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::ShootingInfoColumn, new QStandardItem("ShootingInfo")); horizontalHeaderItem(G::ShootingInfoColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::SearchTextColumn, new QStandardItem("Search")); horizontalHeaderItem(G::SearchTextColumn)->setData(true, G::GeekRole);
    setHorizontalHeaderItem(G::ErrColumn, new QStandardItem("Load Metadata Errors")); horizontalHeaderItem(G::ErrColumn)->setData(true, G::GeekRole);
}

class SortFilter : public QSortFilterProxyModel
{
    Q_OBJECT

public:
    SortFilter(QObject *parent, Filters *filters, bool &combineRawJpg);
    bool isFinished();
    bool isSuspended();
    bool &combineRawJpg;

public slots:
    void filterChange(QString src = "");
    void suspend(bool suspendFiltering, QString src = "");
protected:
    bool filterAcceptsRow(int sourceRow, const QModelIndex &sourceParent) const override;
private:
    Filters *filters;
    mutable bool finished;
    bool suspendFiltering;
};

SortFilter::SortFilter(QObject *parent, Filters *filters, bool &combineRawJpg) :
    QSortFilterProxyModel(parent),
    combineRawJpg(combineRawJpg)
{
    this->filters = filters;
}

bool SortFilter::filterAcceptsRow(int sourceRow, const QModelIndex &sourceParent) const
{
    if (suspendFiltering) {
        return true;
    }

    if (!G::allMetadataLoaded) {
        return true;
    }

    if (combineRawJpg) {
        QModelIndex rawIdx = sourceModel()->index(sourceRow, 0, sourceParent);
        if (rawIdx.data(G::DupHideRawRole).toBool()) {
            return false;
        }
    }

    finished = false;
    static int counter = 0;
    int dataModelColumn = 0;
    bool isMatch = true;                   // overall match
    bool isCategoryUnchecked = true;
    QString itemCategory;                  // for debugging

    // cycle through the filters and identify matches
    QTreeWidgetItemIterator filter(filters);
    while (*filter) {
        if ((*filter)->parent()) {
            if ((*filter)->checkState(0) != Qt::Unchecked) {  // crash
                if ((*filter) == filters->searchTrue &&
                    (*filter)->text(0) == filters->enterSearchString)
                {
                    isMatch = true;
                }
                else {
                    isCategoryUnchecked = false;
                    QModelIndex idx = sourceModel()->index(sourceRow, dataModelColumn, sourceParent);
                    QVariant dataValue = idx.data(Qt::EditRole);
                    QVariant filterValue = (*filter)->data(1, Qt::EditRole);
                    QString itemName = (*filter)->text(0);      // for debugging

                    if (dataValue.typeId() == QMetaType::QStringList) {  // keywords
                        if (dataValue.toStringList().contains(filterValue)) isMatch = true;
                    }
                    else {
                        if (dataValue == filterValue) isMatch = true;
                    }
                }
            }
        }
        else {
            if (isCategoryUnchecked) isMatch = true;
            if (!isMatch) {
                finished = true;
                return false;   // no match in category
            }

            dataModelColumn = (*filter)->data(0, G::ColumnRole).toInt();
            isCategoryUnchecked = true;
            isMatch = false;
            itemCategory = (*filter)->text(0);      // for debugging
        }
        if (suspendFiltering) {
            finished = true;
            return false;
        }
        ++filter;
    }
    if (isCategoryUnchecked) isMatch = true;
    finished = true;

    return isMatch;
}

void SortFilter::filterChange(QString src)
{
    if (suspendFiltering) return;

    invalidateRowsFilter();
}

void SortFilter::suspend(bool suspendFiltering, QString src)
{
    this->suspendFiltering = suspendFiltering;
}

bool SortFilter::isFinished()
{
    return finished;
}

bool SortFilter::isSuspended()
{
    return suspendFiltering;
}

Gulp 5 ---------------------------------------------------------------------------------

MW::initialize() {
    connect(this, &MW::initializeImageCache,
            imageCache, &ImageCache::initialize,
            Qt::BlockingQueuedConnection);
    connect(metaRead, &MetaRead::select, sel, &Selection::setCurrentIndex);
    connect(metaRead, &MetaRead::fileSelectionChange, this, &MW::fileSelectionChange);
    connect(metaRead, &MetaRead::done, this, &MW::folderChangeCompleted);
    metaRead->metaReadThread.start();
}

void MW::folderChanged()
{
    int startRow = 0;

    int rows = dm->rowCount();
    int maxIconsToLoad = rows < dm->iconChunkSize ? rows : dm->iconChunkSize;
    G::metaCacheMB = (maxIconsToLoad * 0.18) + (rows * 0.02);

    if (dm->isAllMetadataAttempted()) {
        G::allMetadataLoaded = true;
        G::iconChunkLoaded = true;
        folderChangeCompleted();
        return;
    }

    // no sorting or filtering until all metadata loaded
    reverseSortBtn->setEnabled(false);
    filters->setEnabled(false);
    filterMenu->setEnabled(false);
    sortMenu->setEnabled(false);

    QMetaObject::invokeMethod(metaRead, "initialize", Qt::BlockingQueuedConnection);

    int netCacheMBSize = cacheMaxMB - G::metaCacheMB;
    if (netCacheMBSize < cacheMinMB) netCacheMBSize = cacheMinMB;
    emit initializeImageCache(netCacheMBSize, cacheMinMB,
                              isShowCacheProgressBar, cacheWtAhead);

    dm->setIconRange(startRow);
    QMetaObject::invokeMethod(metaRead, "setStartRow", Qt::QueuedConnection,
                              Q_ARG(int, startRow),
                              Q_ARG(bool, true),
                              Q_ARG(QString, fun)
                              );
}

class MetaRead : public QObject
{
    Q_OBJECT

public:
    MetaRead(QObject *parent,
             DataModel *dm,
             Metadata *metadata,
             // FrameDecoder *frameDecoder,
             ImageCache *imageCache);
    ~MetaRead() override;

    QThread metaReadThread;       // Separate thread for MetaRead

    int readerCount;
    QVector<Reader*> reader;
    void stop();
    void stopReaders();
    void abortReaders();
    void syncInstance();
    QString reportMetaCache();
    void cleanupIcons();
    QString diagnostics();

    bool isDispatching;

    int firstIconRow;
    int lastIconRow;

    bool showProgressInStatusbar = true;
    bool isDebug = false;

    void test();

signals:
    void stopped(QString src);
    void updateScroll();
    void runStatus(bool/*isRunning*/, bool/*showCacheLabel*/, bool /*success*/, QString/*calledBy*/);
    void centralMsg(QString message);
    void okToSelect(bool ok);
    void select(QModelIndex sfIdx, bool clearSelection);
    void updateProgressInFilter(int progress);
    void updateProgressInStatusbar(int progress, int total);

    void setMsToRead(QModelIndex dmIdx, QVariant value, int instance, QString src = "MetaRead::dispatch",
                     int role = Qt::EditRole, int align = Qt::AlignRight);
    void setIcon(QModelIndex dmIdx, const QPixmap pm, int fromInstance, QString src);

    void fileSelectionChange(QModelIndex sfIdx,
                             QModelIndex idx2 = QModelIndex(),
                             bool clearSelection = false,
                             QString src = "MetaRead::dispatch");

    void done();
    void dispatchIsFinished(QString src);

public slots:
    void initialize(QString src = "");
    void dispatchReaders();
    void dispatch(int id, bool isReturning);
    void setStartRow(int row, bool fileSelectionChanged, QString src = "");
    void dispatchFinished(QString src);

private:
    void read(int startRow = 0, QString src = "");// decoder
    void processReturningReader(int id, Reader *r);
    void quitAfterTimeout();
    bool allMetaIconLoaded();
    void redo();
    int pending();
    inline bool needToRead(int row);
    bool nextA();
    bool nextB();
    bool nextRowToRead();
    void emitFileSelectionChangeWithDelay(const QModelIndex &sfIdx, int msDelay);

    QMutex mutex;
    QWaitCondition condition;
    bool abort;

    QEventLoop runloop;

    QVector<Reader*> readers;
    QVector<QThread*> readerThreads;
    QVector<bool> cycling;
    bool allReadersCycling();

    DataModel *dm;
    Metadata *metadata;
    FrameDecoder *frameDecoder;     // decoder requires this
    ImageCache *imageCache;
    Thumb *thumb;                   // decoder requires this
    bool fileSelectionChanged;
    int instance;                   // new instance for each folder to detect conflict
    Reader *r;                      // terse ptr for current decoder
    int sfRowCount;
    int dmRowCount;
    int metaReadCount;
    int metaReadItems;
    double expansionFactor = 1.2;
    int iconLimit;
    int redoCount = 0;
    int redoMax = 5;
    bool imageCacheTriggered;

    // bool isDispatching;
    bool success;
    bool isDone;
    bool aIsDone;
    bool bIsDone;
    bool quitAfterTimeoutInitiated;

    int startRow = 0;
    int prevStartRow = -1;
    int lastRow;
    int nextRow = 0;
    int a = 0;
    int b = -1;
    bool isAhead;
    bool isNewStartRowWhileDispatching;
    bool needMeta;
    bool needIcon;
    QString src;

    QStringList err;

    bool debugLog;
    int col0Width = 40;
    QString msElapsed();

    QElapsedTimer t;
    QElapsedTimer tAbort;
    QTimer *quitTimer;
    quint32 ms;
};

MetaRead::MetaRead(QObject *parent,
                   DataModel *dm,
                   Metadata *metadata,
                   ImageCache *imageCache)
    : QObject(nullptr),
      quitTimer(new QTimer(this))

{
    moveToThread(&metaReadThread);

    this->dm = dm;
    this->metadata = metadata;
    this->frameDecoder = frameDecoder;
    this->imageCache = imageCache;

    readerCount = QThread::idealThreadCount();
    for (int id = 0; id < readerCount; ++id) {
        Reader *reader = new Reader(id, dm, imageCache);
        QThread *thread = new QThread;
        reader->readerThread = thread;
        reader->moveToThread(thread);
        connect(reader, &Reader::done, this, &MetaRead::dispatch);
        thread->start();
        readers.append(reader);
        readerThreads.append(thread);
        cycling.append(false);
    }

    quitTimer->setSingleShot(true);

    connect(quitTimer, &QTimer::timeout, this, [this]() {
        dispatchFinished("QuitAfterTimeout");
    });

    instance = 0;
    abort = false;
}

void MetaRead::initialize(QString src)
{
     abort = true;
    dmRowCount = dm->rowCount();
    metaReadCount = 0;
    metaReadItems = dmRowCount;
    prevStartRow = -1;
    isAhead = true;
    aIsDone = false;
    bIsDone = false;
    isDone = false;
    success = false;
    quitAfterTimeoutInitiated = false;
    if (quitTimer->isActive()) quitTimer->stop();
    redoCount = 0;
    redoMax = 5;
    err.clear();
    cycling.fill(false);
}

void MetaRead::setStartRow(int sfRow, bool fileSelectionChanged, QString src)
{
    this->fileSelectionChanged = fileSelectionChanged;
    QMutexLocker locker(&mutex);
    abort = false;

    startRow = sfRow;
    prevStartRow = startRow;

    this->src = src;
    sfRowCount = dm->sf->rowCount();
    lastRow = sfRowCount - 1;
    imageCacheTriggered = false;
    aIsDone = false;
    bIsDone = false;
    if (startRow == 0) bIsDone = true;
    isDone = false;
    success = false;
    firstIconRow = dm->startIconRange;      // just use dm->startIconRange ?  RGH
    lastIconRow = dm->endIconRange;

    if (instance == dm->instance) {
        isNewStartRowWhileDispatching = isDispatching;
        if (!isDispatching) {
            a = startRow;
            b = startRow - 1;
        }
    }
    else {
        instance = dm->instance;
        isNewStartRowWhileDispatching = false;
        a = startRow;
        b = startRow - 1;
    }

    dispatchReaders();
}

void MetaRead::dispatchReaders()
{
    isDispatching = true;
    bool isReturning = false;

    for (int id = 0; id < readers.count(); id++) {
        if (!cycling.at(id)) {
            cycling[id] = true;
            if (!abort) dispatch(id, isReturning);
        }
        if (abort) return;
    }
}

void MetaRead::dispatch(int id, bool isReturning)

    r = readers[id];

    if (abort) {
        r->status = Reader::Status::Ready;
        return;
    }

    // New reader and less rows (images to read) than readers - do not dispatch
    if (!isReturning && id >= dmRowCount) {
        return;
    }

    if (isReturning && r->instance == dm->instance) {
        processReturningReader(id, r);

    }

    /* check if new start row while dispatch reading all metadata. The user may have
    jumped to the end of a large folder while metadata is being read. Also could have
    scrolled. */

    if (isNewStartRowWhileDispatching) {
        a = startRow;
        b = startRow - 1;
        isNewStartRowWhileDispatching = false;
    }

    if (nextRowToRead()) {
        QModelIndex sfIdx = dm->sf->index(nextRow, 0);
        QModelIndex dmIdx = dm->modelIndexFromProxyIndex(sfIdx);
        QString fPath = sfIdx.data(G::PathRole).toString();
        if (!abort) {
            QMetaObject::invokeMethod(readers.at(id), "read", Qt::QueuedConnection,
                                      Q_ARG(QModelIndex, dmIdx),
                                      Q_ARG(QString, fPath),
                                      Q_ARG(int, dm->instance),
                                      Q_ARG(bool, needMeta),
                                      Q_ARG(bool, needIcon)
                                      );
        }
    }

    // if done in both directions fire delay to quit in case isDone fails
    if (aIsDone && bIsDone && !isDone) {
        quitAfterTimeout();
    }
}

void MetaRead::processReturningReader(int id, Reader *r)
{
    int dmRow = r->dmIdx.row();

    // progress counter
    metaReadCount++;

    // trigger MW::fileSelectionChange which starts ImageCache
    if (fileSelectionChanged &&
        !imageCacheTriggered &&
        instance == dm->instance &&
        dmRow == startRow
        )
    {
        imageCacheTriggered = true;
        QModelIndex sfIdx = dm->sf->index(r->dmIdx.row(),0);
        bool clearSelection = true;
        QString src = "MetaRead::dispatch";
        emit select(sfIdx, clearSelection);
        emit fileSelectionChange(sfIdx, QModelIndex(), clearSelection, src);
    }

    if (aIsDone && bIsDone) {
        if (pending()) return;

        if (!allMetaIconLoaded()) {
            // if all readers finished but not all loaded, then redo
            if (redoCount < redoMax) {
                // try to read again
                metaReadThread.msleep(50);
                if (!abort) {
                    redo();
                }
            }
            else {
                qWarning() << "REDO MAXED OUT";
            }
        }
        // Now we are done
        dispatchFinished("WeAreDone");
    }
}

inline bool MetaRead::needToRead(int sfRow)
{
    needIcon = false;
    needMeta = false;

    bool isReading = dm->sf->index(sfRow, G::MetadataReadingColumn).data().toBool();
    bool isIcon = dm->sf->index(sfRow, G::IconLoadedColumn).data().toBool();
    bool isMeta = dm->sf->index(sfRow, G::MetadataAttemptedColumn).data().toBool();

    if (isReading || isIcon) {
        return false;
    }
    else {
        QModelIndex sfReadingIdx = dm->sf->index(sfRow, G::MetadataReadingColumn);
        dm->sf->setData(sfReadingIdx, true);
    }

    if (!isMeta) {
        needMeta = true;
    }
    if (!isIcon) {
        if (sfRow >= firstIconRow && sfRow <= lastIconRow) {
            needIcon = true;
        }
    }
    return needMeta || needIcon;
}

bool MetaRead::nextA()
{
    if (aIsDone) return false;
    // use dm->sf->rowCount() in case more folders have been added
    for (int i = a; i < dm->sf->rowCount(); i++) {
        if (needToRead(i)) {
            nextRow = i;
            a = i + 1;
            if (a == sfRowCount) aIsDone = true;
            if (!bIsDone) isAhead = false;
            return true;
        }
    }
    a = sfRowCount;
    aIsDone = true;
    return false;
}

bool MetaRead::nextB()
{
    if (bIsDone) return false;
    for (int i = b; i >= 0; i--) {
        if (needToRead(i)) {
            nextRow = i;
            b = i - 1;
            if (!aIsDone) isAhead = true;
            return true;
        }
    }
    b = -1;
    bIsDone = true;
    return false;
}

bool MetaRead::nextRowToRead()
{
    if (isAhead) {
        if (nextA()) return true;
        else if (nextB()) return true;
        else return false;
    }
    else {
        if (nextB()) return true;
        else if (nextA()) return true;
        else return false;
    }
}

int MetaRead::pending()
{
    int pendingCount = 0;
    for (int id = 0; id < readerCount; ++id) {
        if (readers[id]->pending) {
            pendingCount ++;
        }
    }
    return pendingCount;
}

Gulp 5 ---------------------------------------------------------------------------------

class Reader : public QObject
{
    Q_OBJECT
public:
    Reader(int id, DataModel *dm, ImageCache *imageCache);
    ~Reader() override;

    QThread *readerThread;  // use if currentThread() not working in stop()
    int threadId = -1;
    int instance = 0;
    qint64 msToRead;
    QString fPath = "";
    QString errMsg = "";
    QModelIndex dmIdx = QModelIndex();
    Metadata *metadata;
    QPixmap pm;
    bool pending = false;
    bool loadedIcon = false;

    enum Status {
        Ready,
        Success,
        Aborted,
        MetaFailed,
        IconFailed,
        MetaIconFailed
    } status;
    QStringList statusText {
        "Ready",
        "Success",
        "Aborted",
        "MetaFailed",
        "IconFailed",
        "MetaIconFailed"
    };

signals:
    void videoFrameDecode(QString fPath, int longSide, QString source,
                          QModelIndex dmIdx, int dmInstance);
    void tiffMissingThumbDecode(QString fPath, QModelIndex dmIdx, int instance, int offset);
    void addToDatamodel(ImageMetadata m, QString src);
    void setIcon(QModelIndex dmIdx, const QPixmap pm, int fromInstance, QString src);
    void addToImageCache(int row, QString fPath, int instance);
    void done(int threadId, bool isReturning);

public slots:
    void read(QModelIndex dmIdx, QString filePath, int instance,
              bool needMeta, bool needIcon);
    void abortProcessing();
    void stop();

private:
    QMutex mutex;
    QWaitCondition condition;
    bool abort = false;
    bool readMetadata();
    void readIcon();
    inline bool instanceOk();
    DataModel *dm;
    ImageMetadata *m;
    ImageCache *imageCache;
    FrameDecoder *frameDecoder;
    QThread *frameDecoderthread;
    TiffThumbDecoder *tiffThumbDecoder;
    QThread *tiffThumbDecoderThread;
    Thumb *thumb;

    uint offsetThumb;
    uint lengthThumb;

    int metaReadCount;
    bool isVideo;
    bool isDebug;
    bool debugLog;
    int col0Width = 40;
    QElapsedTimer t;
};

#include "reader.h"
#include "Main/global.h"

Reader::Reader(int id, DataModel *dm, ImageCache *imageCache): QObject(nullptr)
{
    this->dm = dm;
    metadata = new Metadata;
    this->imageCache = imageCache;
    threadId = id;
    instance = 0;

    connect(this, &Reader::addToDatamodel, dm, &DataModel::addMetadataForItem);
    connect(this, &Reader::setIcon, dm, &DataModel::setIcon);

    thumb = new Thumb(dm);

    frameDecoder = new FrameDecoder();
    connect(frameDecoder, &FrameDecoder::setFrameIcon, dm, &DataModel::setIconFromVideoFrame);
    connect(this, &Reader::videoFrameDecode, frameDecoder, &FrameDecoder::addToQueue);
    frameDecoderthread = new QThread;
    frameDecoder->moveToThread(frameDecoderthread);
    frameDecoderthread->start();

    tiffThumbDecoder = new TiffThumbDecoder();
    connect(tiffThumbDecoder, &TiffThumbDecoder::setIcon, dm, &DataModel::setIcon);
    connect(this, &Reader::tiffMissingThumbDecode, tiffThumbDecoder, &TiffThumbDecoder::addToQueue);
    tiffThumbDecoderThread = new QThread;
    tiffThumbDecoder->moveToThread(tiffThumbDecoderThread);
    tiffThumbDecoderThread->start();
}

Reader::~Reader()
{
    frameDecoderthread->quit();
    frameDecoderthread->wait();
    tiffThumbDecoderThread->quit();
    tiffThumbDecoderThread->wait();
}

void Reader::stop()
{
        QMutexLocker locker(&mutex);
        abort = true;
        thumb->abortProcessing();
    }

    if (readerThread->isRunning()) {
        readerThread->quit();
        if (QThread::currentThread() != readerThread) {
            readerThread->wait();
        }
    }
}

void Reader::abortProcessing()
{
    mutex.lock();
    abort = true;
    thumb->abortProcessing();
    status = Status::Aborted;
    pending = false;
    mutex.unlock();
}

inline bool Reader::instanceOk()
{
    return instance == dm->instance;
}

bool Reader::readMetadata()
{
    int dmRow = dmIdx.row();
    QFileInfo fileInfo(fPath);
    bool isMetaLoaded = false;
    if (!abort) isMetaLoaded = metadata->loadImageMetadata(fileInfo, dmRow, instance, true, true, false, true, "Reader::readMetadata");
    if (abort) return false;

    m = &metadata->m;
    m->row = dmRow;
    m->instance = instance;
    m->metadataAttempted = true;
    m->metadataLoaded = isMetaLoaded;
    // req'd to readIcon, in case it runs before datamodel has been updated
    offsetThumb = m->offsetThumb;
    lengthThumb = m->lengthThumb;

    if (!abort) emit addToDatamodel(metadata->m, "Reader::readMetadata");
    return isMetaLoaded;
}

void Reader::readIcon()
{
    int dmRow = dmIdx.row();
    // tiff missing embedded thumbnail
    if (m->ext == "tif" && m->isEmbeddedThumbMissing) {
        emit tiffMissingThumbDecode(fPath, dmIdx, instance, m->offsetFull);
        return;
    }

    if (isVideo) {
        emit videoFrameDecode(fPath, G::maxIconSize, "dmThumb", dmIdx, instance);
        return;
    }

    if (abort) {status = Status::Aborted; return;}

    // pass embedded thumb offset and length in case datamodel not updated yet
    if (offsetThumb && lengthThumb) thumb->presetOffset(offsetThumb, lengthThumb);

    if (abort) {status = Status::Aborted; return;}

    loadedIcon = thumb->loadThumb(fPath, dmIdx, image, instance, "MetaRead::readIcon");

    if (abort) {status = Status::Aborted; return;}

    if (loadedIcon) {
        pm = QPixmap::fromImage(image.scaled(G::maxIconSize, G::maxIconSize, Qt::KeepAspectRatio));
        emit setIcon(dmIdx, pm, instance, "MetaRead::readIcon");
        if (!pm.isNull()) return;
    }

    // failed to load icon, load error icon
    pm = QPixmap(":/images/error_image256.png");
    emit setIcon(dmIdx, pm, instance, "MetaRead::readIcon");
    if (status == Status::MetaFailed) status = Status::MetaIconFailed;
    else status = Status::IconFailed;

}

void Reader::read(QModelIndex dmIdx, QString filePath, int instance,
                  bool needMeta, bool needIcon)
{
    abort = false;
    this->dmIdx = dmIdx;
    fPath = filePath;
    this->instance = instance;
    isVideo = dm->index(dmIdx.row(), G::VideoColumn).data().toBool();
    status = Status::Success;
    pending = true;
    loadedIcon = false;
    offsetThumb = 0;
    lengthThumb = 0;

    if (!abort && needMeta) readMetadata();
    if (!abort && needIcon) readIcon();

    bool isReturning = true;
    if (!abort) emit done(threadId, isReturning);

    pending = false;
}

Gulp 6 ---------------------------------------------------------------------------------

MW::initialize() {
    connect(imageCache, &ImageCache::waitingForRow, dm, &DataModel::imageCacheWaiting);
    connect(imageCache, &ImageCache::setCached, dm, &DataModel::setCached);
    connect(imageCache, &ImageCache::setValueSf, dm, &DataModel::setValueSf);
}

void DataModel::setIcon(QModelIndex dmIdx, const QPixmap &pm, int fromInstance, QString src)
{
/*
    This function is subject to potential race conditions, so it is critical that it only
    be called via a connection with Qt::BlockingQueuedConnection.

    Do not use QMutexLocker.
*/
    if (fromInstance != instance) {
        return;
    }
    if (loadingModel) {
        return;
    }
    if (G::stop) {
        return;
    }
    if (!dmIdx.isValid()) {
         return;
    }
    if (dmIdx.row() >= rowCount()) {
        return;
    }

    const QVariant vIcon = QVariant(QIcon(pm));
    setData(dmIdx, vIcon, Qt::DecorationRole);
    setData(index(dmIdx.row(), G::IconLoadedColumn), true);
    setData(index(dmIdx.row(), G::MetadataReadingColumn), false);
}

bool DataModel::addMetadataForItem(ImageMetadata m, QString src)
{
    if (G::stop) return false;
    if (instance > -1 && m.instance != instance) {
        return false;
    }

    int row = m.row;
    if (rowCount() <= row) return false;

    if (!index(row, 0).isValid()) {
        return false;
    }

    QString search = index(row, G::SearchTextColumn).data().toString();

    QMutexLocker locker(&mutex);
    mLock = true;
    setData(index(row, G::SearchColumn), m.isSearch);
    setData(index(row, G::SearchColumn), Qt::AlignCenter, Qt::TextAlignmentRole);
    setData(index(row, G::LabelColumn), m.label);
    setData(index(row, G::LabelColumn), Qt::AlignCenter, Qt::TextAlignmentRole);
    search += m.label;
    setData(index(row, G::_LabelColumn), m._label);
    setData(index(row, G::RatingColumn), m.rating);
    if (m.rating == "0") m.rating = "";
    setData(index(row, G::RatingColumn), Qt::AlignCenter, Qt::TextAlignmentRole);
    if (m._rating == "0") m.rating = "";
    setData(index(row, G::_RatingColumn), m._rating);
    QString sysCreatedDT = index(row, G::CreatedColumn).data().toString();
    QString exifCreatedDT = m.createdDate.toString("yyyy-MM-dd hh:mm:ss.zzz");
    QDateTime createdDT;
    if (m.createdDate.isValid() /*&& exifCreatedDT != sysCreatedDT*/) {
        setData(index(row, G::CreatedColumn), exifCreatedDT);
        createdDT = m.createdDate;
    }
    else {
        createdDT = index(row, G::CreatedColumn).data().toDateTime();
    }
    if (createdDT.isValid()) {
        setData(index(row, G::YearColumn), createdDT.toString("yyyy"));
        setData(index(row, G::DayColumn), createdDT.toString("yyyy-MM-dd"));
    }

    setData(index(row, G::WidthColumn), QString::number(m.width));
    setData(index(row, G::WidthColumn), Qt::AlignCenter, Qt::TextAlignmentRole);
    setData(index(row, G::HeightColumn), QString::number(m.height));
    setData(index(row, G::HeightColumn), Qt::AlignCenter, Qt::TextAlignmentRole);
    setData(index(row, G::AspectRatioColumn), QString::number((aspectRatio(m.width, m.height, m.orientation)), 'f', 2));
    setData(index(row, G::AspectRatioColumn), int(Qt::AlignRight | Qt::AlignVCenter), Qt::TextAlignmentRole);
    setData(index(row, G::DimensionsColumn), QString::number(m.width) + "x" + QString::number(m.height));
    setData(index(row, G::DimensionsColumn), Qt::AlignCenter, Qt::TextAlignmentRole);
    setData(index(row, G::MegaPixelsColumn), QString::number((m.width * m.height) / 1000000.0, 'f', 2));
    setData(index(row, G::MegaPixelsColumn), int(Qt::AlignRight | Qt::AlignVCenter), Qt::TextAlignmentRole);
    setData(index(row, G::LoadMsecPerMpColumn), m.loadMsecPerMp);
    setData(index(row, G::LoadMsecPerMpColumn), Qt::AlignCenter, Qt::TextAlignmentRole);
    setData(index(row, G::OrientationColumn), QString::number(m.orientation));
    setData(index(row, G::OrientationColumn), Qt::AlignCenter, Qt::TextAlignmentRole);
    setData(index(row, G::RotationColumn), QString::number(m.rotationDegrees));
    setData(index(row, G::RotationColumn), Qt::AlignCenter, Qt::TextAlignmentRole);
    setData(index(row, G::CameraMakeColumn), m.make);
    setData(index(row, G::CameraMakeColumn), m.make, Qt::ToolTipRole);
    search += m.make;
    setData(index(row, G::CameraModelColumn), m.model);
    setData(index(row, G::CameraModelColumn), m.model, Qt::ToolTipRole);
    search += m.model;
    setData(index(row, G::ShutterspeedColumn), m.exposureTimeNum);
    setData(index(row, G::ShutterspeedColumn), int(Qt::AlignRight | Qt::AlignVCenter), Qt::TextAlignmentRole);
    setData(index(row, G::ApertureColumn), m.apertureNum);
    setData(index(row, G::ApertureColumn), Qt::AlignCenter, Qt::TextAlignmentRole);
    setData(index(row, G::ISOColumn), m.ISONum);
    setData(index(row, G::ISOColumn), Qt::AlignCenter, Qt::TextAlignmentRole);
    setData(index(row, G::ExposureCompensationColumn), m.exposureCompensation);
    setData(index(row, G::ExposureCompensationColumn), Qt::AlignCenter, Qt::TextAlignmentRole);
    setData(index(row, G::LensColumn), m.lens);
    setData(index(row, G::LensColumn), m.lens, Qt::ToolTipRole);
    search += m.lens;
    setData(index(row, G::FocalLengthColumn), m.focalLengthNum);
    setData(index(row, G::FocalLengthColumn), int(Qt::AlignRight | Qt::AlignVCenter), Qt::TextAlignmentRole);
    setData(index(row, G::FocusXColumn), m.focusX);
    setData(index(row, G::FocusYColumn), m.focusY);
    setData(index(row, G::GPSCoordColumn), m.gpsCoord);
    setData(index(row, G::GPSCoordColumn), m.gpsCoord, Qt::ToolTipRole);
    setData(index(row, G::KeywordsColumn), QVariant(m.keywords));
    setData(index(row, G::KeywordsColumn), Utilities::stringListToString(m.keywords), Qt::ToolTipRole);
    search += Utilities::stringListToString(m.keywords);
    setData(index(row, G::ShootingInfoColumn), m.shootingInfo);
    setData(index(row, G::ShootingInfoColumn), m.shootingInfo, Qt::ToolTipRole);
    search += m.shootingInfo;
    setData(index(row, G::TitleColumn), m.title);
    setData(index(row, G::TitleColumn), m.title, Qt::ToolTipRole);
    search += m.title;
    setData(index(row, G::_TitleColumn), m._title);
    setData(index(row, G::CreatorColumn), m.creator);
    setData(index(row, G::CreatorColumn), m.creator, Qt::ToolTipRole);
    search += m.creator;
    setData(index(row, G::_CreatorColumn), m._creator);
    setData(index(row, G::CopyrightColumn), m.copyright);
    setData(index(row, G::CopyrightColumn), m.copyright, Qt::ToolTipRole);
    search += m.copyright;
    setData(index(row, G::_CopyrightColumn), m._copyright);
    setData(index(row, G::EmailColumn), m.email);
    setData(index(row, G::EmailColumn), m.email, Qt::ToolTipRole);
    search += m.email;
    setData(index(row, G::_EmailColumn), m._email);
    setData(index(row, G::UrlColumn), m.url);
    search += m.url;
    setData(index(row, G::_UrlColumn), m._url);
    setData(index(row, G::CompareColumn), m.compare);
    setData(index(row, G::OffsetFullColumn), m.offsetFull);
    setData(index(row, G::LengthFullColumn), m.lengthFull);
    setData(index(row, G::WidthPreviewColumn), m.widthPreview);
    setData(index(row, G::HeightPreviewColumn), m.heightPreview);
    setData(index(row, G::OffsetThumbColumn), m.offsetThumb);
    setData(index(row, G::LengthThumbColumn), m.lengthThumb);
    setData(index(row, G::samplesPerPixelColumn), m.samplesPerPixel); // reqd for err trapping
    setData(index(row, G::isBigEndianColumn), m.isBigEnd);
    setData(index(row, G::ifd0OffsetColumn), m.ifd0Offset);
    setData(index(row, G::ifdOffsetsColumn), m.ifdOffsets);
    setData(index(row, G::XmpSegmentOffsetColumn), m.xmpSegmentOffset);
    setData(index(row, G::XmpSegmentLengthColumn), m.xmpSegmentLength);
    setData(index(row, G::IsXMPColumn), m.isXmp);
    setData(index(row, G::ICCSegmentOffsetColumn), m.iccSegmentOffset);
    setData(index(row, G::ICCSegmentLengthColumn), m.iccSegmentLength);
    setData(index(row, G::ICCBufColumn), m.iccBuf);
    setData(index(row, G::ICCSpaceColumn), m.iccSpace);
    setData(index(row, G::OrientationOffsetColumn), m.orientationOffset);
    setData(index(row, G::OrientationColumn), m.orientation);
    setData(index(row, G::RotationDegreesColumn), m.rotationDegrees);
    setData(index(row, G::MetadataAttemptedColumn), m.metadataAttempted);
    setData(index(row, G::MetadataLoadedColumn), m.metadataLoaded);
    setData(index(row, G::MissingThumbColumn), m.isEmbeddedThumbMissing);
    setData(index(row, G::CompareColumn), m.compare);
    setData(index(row, G::SearchTextColumn), search.toLower());
    setData(index(row, G::SearchTextColumn), search.toLower(), Qt::ToolTipRole);

    setData(index(row, G::AttemptsColumn), 0);
    setData(index(row, G::DecoderIdColumn), -1);
    setData(index(row, G::DecoderReturnStatusColumn), 0);
    // calc size in MB req'd to store image in cache
    if (!m.video) {
        int w, h;
        m.widthPreview > 0 ? w = m.widthPreview : w = m.width;
        m.heightPreview > 0 ? h = m.heightPreview : h = m.height;
        // 8 bits X 3 channels + 8 bit depth = (32*w*h)/8/1024/1024 = w*h/262144
        float mb;
        if (w == 0 || h == 0) mb = m.size / 1000000;
        else mb = static_cast<float>(w * h * 1.0 / 262144);
        setData(index(row, G::CacheSizeColumn), mb);
    }

    if (m.isReadWrite)
        if (metadata->canEmbedThumb.contains(m.type.toLower()))
            if (m.isEmbeddedThumbMissing) {
                folderHasMissingEmbeddedThumb = true;
            }

    if (row == 0) emit updateClassification();
    mLock = false;

    if (row == imageCacheWaitingForRow) {
        emit rowLoaded();
        imageCacheWaitingForRow = -1;
    }

    bytesUsed += rowBytesUsed(row);

    return true;
}

Gulp 6 ---------------------------------------------------------------------------------

class ImageCacheData : public QObject
{
    Q_OBJECT
public:
    explicit ImageCacheData(QObject *);

    bool contains(const QString &key);
    void insert(const QString &key, const QImage &image);
    void remove(const QString &key);
    void clear();

    // image cache hash
    QHash<QString, QImage> imCache;

    QReadWriteLock rwLock;
};

ImageCacheData::ImageCacheData(QObject *) {}

bool ImageCacheData::contains(const QString &key)
{
    QReadLocker locker(&rwLock);
    return imCache.contains(key);
}

void ImageCacheData::insert(const QString &key, const QImage &image)
{
    QWriteLocker locker(&rwLock);
    imCache.insert(key, image);
}

void ImageCacheData::remove(const QString &key)
{
    QWriteLocker locker(&rwLock);
    imCache.remove(key);
}

void ImageCacheData::clear()
{
    QWriteLocker locker(&rwLock);
    imCache.clear();
}

class ImageCache : public QObject
{
    Q_OBJECT
public:
    ImageCache(QObject *parent, ImageCacheData *icd, DataModel *dm);
    ~ImageCache() override;

    QThread imageCacheThread;  // Separate thread for ImageCache

    bool isRunning() const;

    float getImCacheSize();         // add up total MB cached
    void removeFromCache(QStringList &pathList);
    void rename(QString oldPath, QString newPath);

    void updateStatus(QString instruction, QString source); // update cached send signal
    QString reportToCache();
    QString diagnostics();
    QString reportCacheParameters();
    QString reportCacheDecoders();
    QString reportCacheItemList(QString title = "");
    QString reportImCache();
    QString reportImCacheRows();
    QString reportToCacheRows();
    int col0Width = 50;

    int decoderCount = 1;

    bool debugCaching = false;
    bool debugLog = false;

signals:
    void waitingForRow(int sfRow);
    void setCached(int sfRow, bool isCached, int instance);
    void decode(int sfRow, int instance);
    void setValueSf(QModelIndex sfIdx, QVariant value, int instance, QString src,
                    int role = Qt::EditRole, int align = Qt::AlignLeft); // not used
    void showCacheStatus(QString instruction,
                         float currMB, int maxMB, int targetFirst, int targetLast,
                         QString source = "");
    void centralMsg(QString msg);       // not being used
    void updateIsRunning(bool, bool);   // (isRunning, showCacheLabel)
    void refreshViews(QString fPath, bool isCached, QString src);

public slots:
    void start();
    void stop();
    // void newInstance();
    void abortProcessing();
    void initialize(int cacheSizeMB, int cacheMinMB,
                    bool isShowCacheStatus, int cacheWtAhead);
    void updateImageCacheParam(int cacheSizeMB, int cacheMinMB,
                               bool isShowCacheStatus, int cacheWtAhead);
    void updateInstance();
    void fillCache(int id);
    void setCurrentPosition(QString path, QString src);
    void filterChange(QString currentImageFullPath, QString source = "");
    void cacheSizeChange();
    void colorManageChange();
    void refreshImageCache();
    void reloadImageCache();
    void removeCachedImage(QString fPath);
    void updateToCache();

private slots:
    void dispatch();

private:
    // Not being used - research how this works and if it is a good idea
    QAtomicInt running {0};

    QMutex gMutex;
    QWaitCondition condition;
    int instance;
    bool abort;
    int abortDelay = 1000;
    bool isDecoders = false;

    // rgh retry not being used
    int retry = 0;
    int maxAttemptsToCacheImage = 10;

    bool isInitializing;

    ImageCacheData *icd;
    DataModel *dm;
    Metadata *metadata;

    QVector<ImageDecoder*> decoders;
    QVector<QThread*> decoderThreads;
    QVector<bool> cycling;
    struct CacheItem {
        bool isCaching;
        QString msg;
        int decoderId;
        int instance;
    };
    QList<int> toCache;
    QHash<int,CacheItem> toCacheStatus;
    QList<int> removedFromCache;// items removed in trimOutsideTargetRange
    QVector<float> imageSize;

    int currRow;
    int prevRow;

    bool isForward;
    int step;
    int sumStep;
    int directionChangeThreshold;
    int wtAhead;
    int maxMB;
    int minMB;
    int targetFirst;
    int targetLast;
    bool isShowCacheStatus;
    bool firstDispatchNewDM;

    void launchDecoders(QString src);
    bool okToCache(int id, int sfRow);
    bool nullInImCache();
    void cacheImage(int id, int cacheKey);
    bool cacheUpToDate();
    void decodeNextImage(int id, int sfRow);
    void trimOutsideTargetRange();
    bool anyDecoderCycling();
    void setDirection();
    bool okToDecode(int sfRow, int id, QString &msg);
    int nextToCache(int id);
    void toCacheRemove(int sfRow);
    void toCacheAppend(int sfRow);
    void memChk();
    bool instanceClash(bool id);
    bool isValidKey(int key);

    void updateTargets(bool dotForward, bool isAhead, int &pos,
                       int &amount, bool &isDone, float &sumMB);
    void setTargetRange(int key);
    bool waitForMetaRead(int sfRow, int ms);
    void log(const QString function, const QString comment = "");
};

ImageCache::ImageCache(QObject *parent,
                       ImageCacheData *icd,
                       DataModel *dm)
    : QObject(nullptr)
{
    moveToThread(&imageCacheThread);

    connect(dm, &DataModel::rowLoaded, this, [&] { condition.wakeAll(); });

    // data is kept in ImageCacheData icd, a hash table
    this->icd = icd;
    this->dm = dm;
    metadata = new Metadata;

    // create n decoder threads
    decoderCount = QThread::idealThreadCount();
    for (int id = 0; id < decoderCount; ++id) {
        ImageDecoder *decoder = new ImageDecoder(id, dm, metadata);
        QThread *thread = new QThread;

        decoder->moveToThread(thread);
        connect(decoder, &ImageDecoder::done, this, &ImageCache::fillCache);

        thread->start();
        decoders.append(decoder);
        decoderThreads.append(thread);
        cycling.append(false);
    }

    abort = false;
}

ImageCache::~ImageCache()
{
    stop();
}

void ImageCache::start()
{
    abort = false;
    if (!imageCacheThread.isRunning()) {
        imageCacheThread.start();
    }
}

void ImageCache::stop()
{
    abort = true;

    // Stop all decoder threads first
    for (int id = 0; id < decoderCount; ++id) {
        QMetaObject::invokeMethod(decoders[id], "stop", Qt::BlockingQueuedConnection);
        // decoders[id]->stop();
    }

    if (imageCacheThread.isRunning()) {
        imageCacheThread.quit();
        imageCacheThread.wait();
    }
}

bool ImageCache::instanceClash(bool id)
{
    return decoders[id]->instance != G::dmInstance;
}

void ImageCache::abortProcessing()
{
    abort = true;
    for (int id = 0; id < decoderCount; ++id) {
        cycling[id] = false;
        QMetaObject::invokeMethod(decoders[id], "abortProcessing", Qt::QueuedConnection);
    }
}

bool ImageCache::isRunning() const
{
    // rgh should we use QAtomicInt running
    return imageCacheThread.isRunning();
}

bool ImageCache::anyDecoderCycling()
{
    for (int id = 0; id < decoderCount; ++id) {
        if (cycling.at(id)) return true;
    }
    return false;
}

float ImageCache::getImCacheSize()
{
    float cacheMB = 0;

    for (auto it = icd->imCache.constBegin(); it != icd->imCache.constEnd(); ++it) {
        float mb = static_cast<float>(it.value().sizeInBytes()) / (1 << 20);
        cacheMB += mb;
    }

    return cacheMB;
}

bool ImageCache::isValidKey(int key)
{
    if (key > -1 && key < dm->sf->rowCount()) return true;
    else return false;
}

bool ImageCache::waitForMetaRead(int sfRow, int ms)
{
    if (G::allMetadataLoaded) {
        return true;
    }
    if (dm->sf->index(sfRow, G::MetadataAttemptedColumn).data().toBool()) {
        return true;
    }

    bool isLoaded = false;

    QElapsedTimer t;
    t.start();

    // signal DataModel::imageCacheWaiting
    emit waitingForRow(sfRow);

    while(!isLoaded) {
        if (!condition.wait(&gMutex, ms - t.elapsed())) break;
        isLoaded = dm->sf->index(sfRow, G::MetadataAttemptedColumn).data().toBool();
        if (isLoaded) break;
    }

    return isLoaded;
}

void ImageCache::updateToCache()
{
    QMutexLocker locker(&gMutex);  // req'd to prevent toCacheAppend() crash

    if (!abort) setDirection();
    if (!abort) setTargetRange(currRow);
    if (!abort) trimOutsideTargetRange();

    // update datamodel cached status
    for (int sfRow : removedFromCache) {
        if (abort) break;
        emit setCached(sfRow, false, instance);
    }

    if (instance != dm->instance) instance = dm->instance;
}

void ImageCache::setDirection()
    int thisPrevKey = prevRow;
    prevRow = currRow;
    int thisStep = currRow - thisPrevKey;

    if (sumStep == 0) {
        sumStep += thisStep;
    }
    else {
        // immediate direction changed, reset counter
        if (sumStep > 0 != thisStep > 0) sumStep = thisStep;
        // increment counter
        else sumStep += thisStep;
    }

    if (qAbs(sumStep) > directionChangeThreshold) {
        if (isForward != sumStep > 0) {
            isForward = sumStep > 0;
            sumStep = 0;
        }
    }
}

void ImageCache::trimOutsideTargetRange()
{
    removedFromCache.clear();

    auto it = icd->imCache.begin();
    while (it != icd->imCache.end()) {
        QString fPath = it.key();
        int sfRow = dm->proxyRowFromPath(fPath, src);
        if (!isValidKey(sfRow)) {
            it = icd->imCache.erase(it);
            continue;
        }
        if (sfRow < targetFirst || sfRow > targetLast) {
            it = icd->imCache.erase(it);
             removedFromCache.append(sfRow);
        }
        else {
            ++it; // move forward if no removal
        }
    }

    for (int sfRow : toCache) {
        if (sfRow < targetFirst || sfRow > targetLast) {
            toCacheStatus.remove(sfRow);
            if (isValidKey(sfRow) && !removedFromCache.contains(sfRow)) {
                removedFromCache.append(sfRow);
            }
        }
    }

    auto itt = toCache.begin();  // Ensures a mutable iterator
    toCache.erase(std::remove_if(itt, toCache.end(), [&](int sfRow) {
                      return sfRow < targetFirst || sfRow > targetLast;
                  }), toCache.end());

    updateStatus("Update all rows", src);
}

void ImageCache::setTargetRange(int key)
{
    float sumMB = 0;
    int n = dm->sf->rowCount();
    bool aheadDone = false;
    bool behindDone = false;
    if (key == n - 1) {
        isForward = false;
        targetLast = n - 1;
    }
    if (key == 0) {
        isForward = true;
        targetFirst = 0;
    }
    int aheadPos = key;
    int behindPos = isForward ? (aheadPos - 1) : (aheadPos + 1);
    if (behindPos >= n) behindDone = true;
    if (behindPos < 0) behindDone = true;

    // folders were added or removed from datamodel
    if (instance != dm->instance) {
        toCache.clear();
        toCacheStatus.clear();
    }

    int pos = 0;
    int i = 0;
    while (sumMB < maxMB && !(aheadDone && behindDone)) {
        if (abort) return;
        i++;
        bool isAhead = i % 3;
        if (isForward) {
            if (isAhead && !aheadDone) {
                pos = aheadPos++;
                if (aheadPos >= n) aheadDone = true;
            }
            else if (!behindDone) {
                pos = behindPos--;
                if (behindPos < 0) behindDone = true;
            }
            else continue;
        }
        else {
            if (isAhead && !aheadDone) {
                pos = aheadPos--;
                if (aheadPos < 0) aheadDone = true;
            }
            else if (!behindDone) {
                pos = behindPos++;
                if (behindPos >= n) behindDone = true;
            }
            else continue;
        }

        if (dm->valueSf(pos, G::VideoColumn).toBool()) {
            emit setCached(pos, true, instance);
            pos < key ? targetFirst = pos : targetLast = pos;
        }
        else {
            /* see "Image size in cache" at top of imagecache.cpp
            // this lowers performance
            QVariant mb;
            QMetaObject::invokeMethod(
                dm,
                "valueSf",
                Qt::BlockingQueuedConnection,
                Q_RETURN_ARG(QVariant, mb),
                Q_ARG(int, pos),
                Q_ARG(int, G::CacheSizeColumn)
            );
            sumMB += mb.toFloat();
            //*/

            // fast but risky, can crash when stress testing bounce folders
            sumMB +=  dm->sf->index(pos, G::CacheSizeColumn).data().toFloat();

            QString fPath = dm->valueSf(pos, 0, G::PathRole).toString();
            if (sumMB < maxMB) {
                if (!toCache.contains(pos) && !icd->contains(fPath)) {
                    toCacheAppend(pos);
                }
                pos < key ? targetFirst = pos : targetLast = pos;
            }
        }
    }
}

void ImageCache::removeCachedImage(QString fPath)
{
    int sfRow = dm->proxyRowFromPath(fPath, src);
    QMutexLocker locker(&gMutex);

    icd->imCache.remove(fPath);
    emit refreshViews(fPath, false, "ImageCache::setTargetRange");
}

void ImageCache::removeFromCache(QStringList &pathList)
{
    QMutexLocker locker(&gMutex);
    for (int i = 0; i < pathList.count(); ++i) {
        QString fPathToRemove = pathList.at(i);
        if (icd->imCache.contains(fPathToRemove)) {
            icd->imCache.remove(fPathToRemove);
        }
        int sfRow = dm->proxyRowFromPath(fPathToRemove, "ImageCache::removeFromCache");
        if (toCache.contains(sfRow)) {
            toCacheRemove(sfRow);
        }
    }
}

void ImageCache::rename(QString oldPath, QString newPath)
{
    if (icd->contains(oldPath)) {
        QImage image = icd->imCache.take(oldPath);  // Remove the old key-value pair
        icd->imCache.insert(newPath, image);
    }
}

void ImageCache::toCacheAppend(int sfRow)
{
    if (abort) return;
    toCache.append(sfRow);
    toCacheStatus.insert(sfRow, {false, "", -1, instance});
}

void ImageCache::toCacheRemove(int sfRow)
{
    toCache.removeOne(sfRow);
    toCacheStatus.remove(sfRow);
}

bool ImageCache::cacheUpToDate()
{
    if (toCache.isEmpty()) return true;

    foreach (CacheItem cs, toCacheStatus) {
        if (!cs.isCaching) return false;
    }

    return true;
}

void ImageCache::memChk()
{
    #ifdef Q_OS_WIN
        Win::availableMemory();     // sets G::availableMemoryMB
    #endif

    #ifdef Q_OS_MAC
        Mac::availableMemory();     // sets G::availableMemoryMB
    #endif

    float currMB = getImCacheSize();
    float roomInCache = maxMB - currMB;
    if (G::availableMemoryMB < roomInCache) {
        maxMB = currMB + G::availableMemoryMB;
    }
    if (maxMB < minMB) maxMB = minMB;
}

void ImageCache::updateStatus(QString instruction, QString source)
{
    emit showCacheStatus(instruction, currMB, maxMB, targetFirst, targetLast, source);
}

void ImageCache::initialize(int cacheMaxMB,
                            int cacheMinMB,
                            bool isShowCacheStatus,
                            int cacheWtAhead)
{
    QMutexLocker locker(&gMutex);

    icd->clear();
    toCache.clear();
    toCacheStatus.clear();

    if (!dm->sf->rowCount()) return;

    instance = dm->instance;

    currRow = 0;
    prevRow = -1;
    isForward = true;
    maxMB = cacheMaxMB;
    minMB = cacheMinMB;
    this->isShowCacheStatus = isShowCacheStatus;
    wtAhead = cacheWtAhead;
    targetFirst = 0;
    targetLast = 0;
    directionChangeThreshold = 3;
    firstDispatchNewDM = true;

    isInitializing = false;
    abort = false;
}

void ImageCache::updateInstance()
{
    instance = dm->instance;
}

void ImageCache::updateImageCacheParam(int cacheSizeMB,
                                       int cacheMinMB,
                                       bool isShowCacheStatus,
                                       int cacheWtAhead)
{
    maxMB = cacheSizeMB;
    minMB = cacheMinMB;
    this->isShowCacheStatus = isShowCacheStatus;
    wtAhead = cacheWtAhead;
    reloadImageCache();
}

void ImageCache::filterChange(QString currentImageFullPath, QString src)
{
    if (dm->sf->rowCount() == 0) return;
    if (G::removingRowsFromDM) return;

    instance = dm->instance;

    icd->clear();
    toCache.clear();
    toCacheStatus.clear();
    updateStatus("Clear", "filterChange");

    setCurrentPosition(currentImageFullPath, fun);
}

void ImageCache::refreshImageCache()
{
    abort = false;
    dispatch();
}

void ImageCache::reloadImageCache()
{
    abort = false;
    icd->clear();
    toCache.clear();
    toCacheStatus.clear();
    dispatch();
}

void ImageCache::colorManageChange()
{
    reloadImageCache();
}

void ImageCache::cacheSizeChange()
{
    refreshImageCache();
}

void ImageCache::setCurrentPosition(QString fPath, QString src)
{
    if (G::removingRowsFromDM) return;

     currRow = dm->proxyRowFromPath(fPath, fun);

    if (G::dmInstance != instance) {
        return;
    }

    if (isInitializing) {
        return;
    }

    // range check
    if (currRow >= dm->sf->rowCount()) {
        return;
    }

    abort = false;
    dispatch();
}

bool ImageCache::okToDecode(int sfRow, int id, QString &msg)
{
    if (dm->sf->index(sfRow,G::VideoColumn).data().toBool()) {
        return false;
    }

    QString fPath = dm->sf->index(sfRow, 0).data(G::PathRole).toString();
    if (icd->contains(fPath)) {
        return false;
    }

    if (toCacheStatus.contains(sfRow)) {
        if (toCacheStatus[sfRow].isCaching) {
            return false;
        }
    }

     if (!dm->sf->index(sfRow, G::MetadataAttemptedColumn).data().toBool()) {
        if (!waitForMetaRead(sfRow, 50)) {
            return false;
        }
    }

    return true;

}

int ImageCache::nextToCache(int id)
{
    QString sId = "decoder " + QString::number(id).leftJustified(3);

    QMutexLocker locker(&gMutex);   // req'd 2025-02-03

    if (toCache.isEmpty()) {
        return -1;
    }

     for (int i = 0; i < toCache.count(); ++i) {
        int sfRow = toCache.at(i);

        QString sRow = QString::number(sfRow).leftJustified(5);

        QString msg;

        if (okToDecode(sfRow, id, msg)) {
            return sfRow;
        }
        else {
            continue;
        }
    }
    return -1;
}

void ImageCache::decodeNextImage(int id, int sfRow)
{
    if (toCacheStatus.contains(sfRow)) {
        toCacheStatus[sfRow].isCaching = true;
        toCacheStatus[sfRow].msg = "";
        toCacheStatus[sfRow].decoderId = id;
        toCacheStatus[sfRow].instance = instance;
    }
    emit setValueSf(dm->sf->index(sfRow, G::IsCachingColumn), true, instance, src);
    emit setValueSf(dm->sf->index(sfRow, G::DecoderIdColumn), id, instance, src);
    int attempts = dm->sf->index(sfRow, G::AttemptsColumn).data().toInt();
    attempts++;
    emit setValueSf(dm->sf->index(sfRow, G::AttemptsColumn), attempts, instance, src);

    if (!decoderThreads[id]->isRunning()) decoderThreads[id]->start();

    bool success = false;
    if (!abort)
        success = QMetaObject::invokeMethod(decoders[id], "decode",
                                  Qt::QueuedConnection,
                                  Q_ARG(int, sfRow), Q_ARG(int, instance));

    if (!success) {
         if (!abort) fillCache(id);
    }
}

void ImageCache::cacheImage(int id, int sfRow)
{
    if (!abort) icd->insert(decoders[id]->fPath, decoders[id]->image);

    if (!abort) if (toCache.contains(sfRow)) toCacheRemove(sfRow);

    if (!abort) emit setCached(sfRow, true, instance);

    if (!abort) updateStatus("Update all rows", "ImageCache::cacheImage");
}

bool ImageCache::okToCache(int id, int sfRow)
{
    if (instanceClash(id)) return false;

    if (sfRow >= dm->sf->rowCount()) return false;

    emit setValueSf(dm->sf->index(sfRow, G::IsCachingColumn), false, instance, src);
    if (toCacheStatus.contains(sfRow))
        toCacheStatus[sfRow].isCaching = false;

    emit setValueSf(dm->sf->index(sfRow, G::DecoderReturnStatusColumn),
                    static_cast<int>(decoders[id]->status), instance, src);

    if (!toCache.contains(sfRow)) return false;

    if (decoders[id]->status != ImageDecoder::Status::Success) {
        if (decoders[id]->errMsg != "") {
            emit setValueSf(dm->sf->index(sfRow, G::DecoderErrMsgColumn),
                            decoders[id]->errMsg, instance, src);
        }
        if (toCache.contains(sfRow)) toCacheRemove(sfRow);
        return false;
    }

    float toCacheMB = decoders[id]->image.sizeInBytes() / (1 << 20);
    float currCacheMB = getImCacheSize();
    if ((currCacheMB + toCacheMB) > maxMB) {
        toCache.clear();
        toCacheStatus.clear();
        return false;
    }

    return true;
}

bool ImageCache::nullInImCache()
{
    bool isEmptyImage = false;
    for (const QString &path : icd->imCache.keys()) {
        if (icd->imCache.value(path).width() == 0) {
            int sfRow = dm->proxyRowFromPath(path, "ImageCache::nullInImCache");
            toCacheAppend(sfRow);
            emit setValueSf(dm->sf->index(sfRow, G::IsCachingColumn), true, instance, src);
            isEmptyImage = true;
        }
    }
    return isEmptyImage;
}

void ImageCache::fillCache(int id)
{
    int cacheRow = decoders[id]->sfRow;

    if (okToCache(id, cacheRow)) {
        if (!abort) cacheImage(id, cacheRow);
    }

    int toCacheKey = nextToCache(id);
    bool okDecodeNextImage = !abort && toCacheKey != -1 && isValidKey(toCacheKey);

    if (okDecodeNextImage) {
        if (!abort) decodeNextImage(id, toCacheKey);
    }

    else {

        cycling[id] = false;

        if (!anyDecoderCycling()) {

            if (nullInImCache()) {
                launchDecoders(src);
                return;
            }

            if (isShowCacheStatus) {
                updateStatus("Update all rows", "ImageCache::fillCache after check cacheUpToDate");
            }

            abort = false;
        }
    }
}

void ImageCache::launchDecoders(QString src)
{
    for (int id = 0; id < decoderCount; ++id) {
        if (abort) return;
        if (toCache.isEmpty()) break;
        if (id >= dm->sf->rowCount()) break;
        if (cycling.at(id)) {
            continue;
        }
        int sfRow = nextToCache(id);
        if (sfRow == -1) break;

        cycling[id] = true;
        if (!abort) decodeNextImage(id, sfRow);
    }
}

void ImageCache::dispatch()
{
    abort = false;

    if (!imageCacheThread.isRunning()) {
        // qDebug() << "ImageCache::dispatch imageCacheThread.start()";
        imageCacheThread.start();
    }

    memChk();

    updateToCache();

    if (cacheUpToDate()) {
        return;
    }

    if (!abort) launchDecoders("ImageCache::dispatch");
}
