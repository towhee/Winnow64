1. Alignment quality

Goal: sharper fusion, fewer ‚Äúdouble edges‚Äù.

Options:
        1.	Tune FSAlign options
        ‚Ä¢	matchContrast, matchWhiteBalance, lowRes, maxRes, fullResolution.
        ‚Ä¢	Larger maxRes / fullResolution = true ‚Üí better alignment at the cost of speed.
        ‚Ä¢	Smaller lowRes ‚Üí more precise coarse alignment, but slower.
        2.	Reference frame strategy
        ‚Ä¢	Right now: frame 0 is the reference.
        ‚Ä¢	Alternatives:
        ‚Ä¢	Use the ‚Äúmiddle‚Äù frame of the stack as reference.
        ‚Ä¢	Pick the ‚Äúsharpest‚Äù frame (by a quick focus measure) as reference.
        ‚Ä¢	Better reference can reduce accumulated transform error and warping.
        3.	Pre-conditioning
        ‚Ä¢	Optional mild denoise or contrast-stretch on alignment grayscale images can:
        ‚Ä¢	Make feature matching more robust.
        ‚Ä¢	Reduce mis-alignment in low-contrast areas.

‚∏ª

2. Focus-measure / depth-map logic

Goal: get closer to Zerene-like ‚Äúsmart‚Äù decisions about which slice wins.

Even though your current pipeline is mostly ‚ÄúPetteri PMax in a box‚Äù, you now have a modular place for:
        1.	Alternative focus measures
        ‚Ä¢	Wavelet energy (current).
        ‚Ä¢	Local variance, Laplacian, Tenengrad, etc.
        ‚Ä¢	Multi-measure combination (e.g. wavelet at coarse scale + Laplacian at fine scale).
        2.	Depth-map smoothing
        ‚Ä¢	Apply spatial smoothing/regularization to the depth index:
        ‚Ä¢	Median or bilateral filter on the depth map.
        ‚Ä¢	Guided filtering with the fused gray as guidance.
        ‚Ä¢	This reduces noisy depth flicker between neighbouring pixels ‚Üí smoother fusion, fewer micro-halos.
        3.	Depth constraints (optional)
        ‚Ä¢	If you know stack direction (front‚Üíback), you can:
        ‚Ä¢	Penalize wild depth jumps.
        ‚Ä¢	Encourage locally monotonic or gently varying depth.
        ‚Ä¢	This tends to remove isolated ‚Äúspikes‚Äù and pits in the depth map.
        4.	Depth from Zerene (experimental path)
        ‚Ä¢	You already experimented with using a Zerene depth map as depth_idx.
        ‚Ä¢	Long-term option: a ‚ÄúUse external depth‚Äù mode that:
        ‚Ä¢	Loads a depth_idx-style map.
        ‚Ä¢	Uses your fusion and color pipeline with that depth.

‚∏ª

3. Fusion (PMax) itself

Goal: sharper, more Zerene-like output, fewer halos.
        1.	Merge consistency level
        ‚Ä¢	Your Task_Merge has consistency levels:
        ‚Ä¢	0 = pure max selection.
        ‚Ä¢	1 = subband voting.
        ‚Ä¢	2 = subband + neighbour denoise.
        ‚Ä¢	Increasing this:
        ‚Ä¢	Smooths depth decisions.
        ‚Ä¢	Reduces ‚Äúpepper noise‚Äù and small halos.
        ‚Ä¢	Costs some CPU.
        2.	Wavelet levels / padding
        ‚Ä¢	You now control levels via FSFusionWavelet and padding.
        ‚Ä¢	More levels (deeper pyramid):
        ‚Ä¢	Better separation of fine detail vs large blur.
        ‚Ä¢	Sharper PMax but more sensitive to noise and halos.
        ‚Ä¢	Fewer levels:
        ‚Ä¢	Faster, a bit softer, often fewer halos.
        3.	Post-fusion local contrast
        ‚Ä¢	After inverse wavelet, you can:
        ‚Ä¢	Apply micro-contrast / clarity-style adjustment.
        ‚Ä¢	Apply gentle tone-curve stretching.
        ‚Ä¢	This can push your output visually closer to Zerene‚Äôs PMax ‚Äúbite‚Äù.
        4.	Depth-aware blending between slices
        ‚Ä¢	Instead of hard winner-take-all, you can:
        ‚Ä¢	Blend neighbouring slices in depth where depth indices are close.
        ‚Ä¢	That reduces seams along edges and some halo types.

‚∏ª

4. Halo reduction

Goal: fix the bright/dark fringes around edges in the fused result.

You already have a FocusHalo subsystem in the original Winnow pipeline. For the Petteri path you have options:
        1.	Reuse your existing halo remover
        ‚Ä¢	Run FocusHalo on the PMax output as a post-process.
        ‚Ä¢	This is low-risk: you don‚Äôt touch the Petteri internals at first.
        2.	Depth-guided halo cleanup
        ‚Ä¢	Detect strong local gradient + large depth jumps ‚Üí likely halo region.
        ‚Ä¢	Locally blend:
        ‚Ä¢	Fused result with one of the source slices.
        ‚Ä¢	Or with a more conservative focus measure.
        ‚Ä¢	This targets halos only where depth changes abruptly.
        3.	More conservative PMax (less ‚Äúaggressive‚Äù selection)
        ‚Ä¢	Using consistency level 2 and maybe fewer levels:
        ‚Ä¢	Often reduces halos at the cost of a slightly softer image.
        ‚Ä¢	You can offer a ‚ÄúZerene-like‚Äù vs ‚ÄúAggressive PMax‚Äù preset.

‚∏ª

5. Color handling and bit depth

Goal: best possible color and tonal smoothness, especially if you go to 16-bit output.
        1.	Keep color 16-bit as long as possible
        ‚Ä¢	Aligned color already comes from 8- or 16-bit sources.
        ‚Ä¢	Your current FSFusionReassign:
        ‚Ä¢	Converts 16UC3 ‚Üí 8UC3 for building the color map.
        ‚Ä¢	Option:
        ‚Ä¢	Still build the map in 8-bit space (for logic simplicity).
        ‚Ä¢	Write 16-bit TIFF by scaling the chosen 8-bit color to 16-bit (√ó257).
        ‚Ä¢	This preserves smoother gradients in the final file even if mapping logic is 8-bit.
        2.	Linear vs gamma-encoded color
        ‚Ä¢	If aligned color is in gamma-encoded space (sRGB), PMax can over-emphasize highlights.
        ‚Ä¢	Optional improvement:
        ‚Ä¢	Convert color to a linearized space for reassignment, then re-encode to sRGB at the end.
        3.	White balance and exposure
        ‚Ä¢	FSAlign already has matchWhiteBalance and matchContrast.
        ‚Ä¢	Making sure color is consistent across stack:
        ‚Ä¢	Reduces color flicker in the fused result.
        ‚Ä¢	Helps the reassignment map stay compact and predictable.

‚∏ª

6. Performance and usability

Goal: shorter run times and smoother UX without hurting quality.
        1.	Use in-memory Mats when available
        ‚Ä¢	You are already partway there:
        ‚Ä¢	m_alignedColorMats / m_alignedGrayMats from runAlign().
        ‚Ä¢	When these are populated:
        ‚Ä¢	Skip disk I/O entirely in runFusion().
        ‚Ä¢	For 12√ó20MP stacks that‚Äôs a big quality-of-life win.
        2.	OpenCL toggle
        ‚Ä¢	useOpenCL already gives a big speed-up in forward/inverse wavelet.
        ‚Ä¢	For debugging or older GPUs:
        ‚Ä¢	Allow a ‚ÄúCPU only‚Äù switch.
        ‚Ä¢	For production:
        ‚Ä¢	Default to OpenCL where stable ‚Üí keep current good performance.
        3.	Parallelism at the slice level
        ‚Ä¢	Forward wavelet per slice is embarrassingly parallel:
        ‚Ä¢	You can run multiple slices at once using QtConcurrent or your own thread pool.
        ‚Ä¢	Same for building the color map if you ever split it into tiles.
        4.	Preview vs final mode
        ‚Ä¢	Fast ‚Äúpreview‚Äù:
        ‚Ä¢	Fewer levels.
        ‚Ä¢	Lower consistency.
        ‚Ä¢	Maybe half-resolution input.
        ‚Ä¢	‚ÄúFinal render‚Äù:
        ‚Ä¢	Full levels, consistency 2, full-res.
        ‚Ä¢	This would let you iterate on settings quickly.

‚∏ª

7. Workflow / controls in Winnow

Goal: give you knobs without touching code each time.

Things that map nicely into UI options:
        ‚Ä¢	PMax profile:
        ‚Ä¢	‚ÄúFast‚Äù / ‚ÄúBalanced‚Äù / ‚ÄúMax Quality‚Äù.
        ‚Ä¢	Consistency level: 0 / 1 / 2.
        ‚Ä¢	Use OpenCL: on/off.
        ‚Ä¢	Keep intermediates: on/off (already in Options).
        ‚Ä¢	Output bit depth: 8-bit / 16-bit TIFF.
        ‚Ä¢	Halo reduction: off / mild / strong.


We can start with clean, minimal versions that:
        ‚Ä¢	Use in-memory Mats from runAlign()
        ‚Ä¢	Save only if keepIntermediates==true
        ‚Ä¢	Produce a real depth_index.png preview (you already have reference images)

Then later we enhance:
        ‚Ä¢	Focus metric quality
        ‚Ä¢	Depth smoothing
        ‚Ä¢	Depth confidence
        ‚Ä¢	Depth-aware halo reduction

NOTES AFTER RE-ARCHITECT: (2025-12-10)

2. Depth becomes a FIRST-CLASS citizen

Before:
Fusion also secretly computed its own depth (wavelet merges).
That meant artifacts could originate from either stage, and diagnosing them was hard.

Now:
        ‚Ä¢	Depth is a single, authoritative product of FSDepth.
        ‚Ä¢	Fusion must consume it.
        ‚Ä¢	MultiScale depth = exactly the wavelet-based PMax logic.
        ‚Ä¢	Simple depth = fast, standard scalar-metric argmax.

This makes it trivial to compare or introduce new depth estimators:
        ‚Ä¢	Bilateral-smoothed depth
        ‚Ä¢	Multi-scale confidence maps
        ‚Ä¢	Machine-learning focus measure
        ‚Ä¢	Hybrid depth (blend wavelet + local contrast)
        ‚Ä¢	Depth consistency refinement

The architecture supports them without touching Fusion.

‚∏ª

3. Fusion stage becomes pluggable with no cross-dependencies

Fusion now takes only:
        ‚Ä¢	aligned gray stack
        ‚Ä¢	aligned color stack
        ‚Ä¢	canonical depth map
        ‚Ä¢	method choice (‚ÄúPMax‚Äù, ‚ÄúSimple‚Äù, future methods)

This is perfect for adding:

üîπ PMax2 (your improved PMax)
        ‚Ä¢	Multi-scale soft blending
        ‚Ä¢	Contrast-weighted correction
        ‚Ä¢	Edge-aware halo suppression
        ‚Ä¢	Wavelet residual correction

üîπ DMap Fusion (depth-only selection)
        ‚Ä¢	Already implemented (‚ÄúSimple‚Äù)

üîπ Hybrid fusion
        ‚Ä¢	Use depth to pick ‚Äúblocks‚Äù, then use wavelets within blocks

üîπ Full GPU fusion
        ‚Ä¢	Depth unchanged
        ‚Ä¢	Only wavelet transforms move to GPU

Since depth is fixed and external, fusion methods can be swapped freely.

‚∏ª

4. Performance improvements become easy

Because stages are modular, you can independently optimize:

Alignment

GPU transforms via OpenCL, NEON, or Vulkan
Parallel align of subregions

Focus

Parallel wavelet metrics
SIMD focus measure

Depth

GPU-accelerated FSFusionMerge
Multi-threaded depth refinement
Confidence map generation

Fusion

Reuse wavelet forward transforms
Avoid recomputing padded images
GPU inverse wavelet & color reassignment

All optimizations are local to their stage.

‚∏ª

5. Debugging becomes dramatically easier

You now have canonical artifacts at each stage:
        ‚Ä¢	gray_*.tif
        ‚Ä¢	focus_*.tif
        ‚Ä¢	wavelet debug images
        ‚Ä¢	depth_index.png
        ‚Ä¢	fusion result

If an artifact appears:
        ‚Ä¢	Is the chosen depth too shallow? ‚Üí depth stage
        ‚Ä¢	Is fusion causing halos? ‚Üí fusion stage
        ‚Ä¢	Are focus maps flat? ‚Üí focus stage
        ‚Ä¢	Are aligned frames drifting? ‚Üí align stage

If you‚Äôre ready, the next step I recommend is:

‚ú® Add a confidence map to the MultiScale depth

(which will drastically reduce halo issues)

Or‚Äî

‚ú® Add a PMax2 fusion method

which will use:
        ‚Ä¢	depth edges
        ‚Ä¢	slice local contrast
        ‚Ä¢	multi-level blending
        ‚Ä¢	artifact suppression
