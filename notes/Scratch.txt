1. Alignment quality

Goal: sharper fusion, fewer “double edges”.

Options:
        1.	Tune FSAlign options
        •	matchContrast, matchWhiteBalance, lowRes, maxRes, fullResolution.
        •	Larger maxRes / fullResolution = true → better alignment at the cost of speed.
        •	Smaller lowRes → more precise coarse alignment, but slower.
        2.	Reference frame strategy
        •	Right now: frame 0 is the reference.
        •	Alternatives:
        •	Use the “middle” frame of the stack as reference.
        •	Pick the “sharpest” frame (by a quick focus measure) as reference.
        •	Better reference can reduce accumulated transform error and warping.
        3.	Pre-conditioning
        •	Optional mild denoise or contrast-stretch on alignment grayscale images can:
        •	Make feature matching more robust.
        •	Reduce mis-alignment in low-contrast areas.

⸻

2. Focus-measure / depth-map logic

Goal: get closer to Zerene-like “smart” decisions about which slice wins.

Even though your current pipeline is mostly “Petteri PMax in a box”, you now have a modular place for:
        1.	Alternative focus measures
        •	Wavelet energy (current).
        •	Local variance, Laplacian, Tenengrad, etc.
        •	Multi-measure combination (e.g. wavelet at coarse scale + Laplacian at fine scale).
        2.	Depth-map smoothing
        •	Apply spatial smoothing/regularization to the depth index:
        •	Median or bilateral filter on the depth map.
        •	Guided filtering with the fused gray as guidance.
        •	This reduces noisy depth flicker between neighbouring pixels → smoother fusion, fewer micro-halos.
        3.	Depth constraints (optional)
        •	If you know stack direction (front→back), you can:
        •	Penalize wild depth jumps.
        •	Encourage locally monotonic or gently varying depth.
        •	This tends to remove isolated “spikes” and pits in the depth map.
        4.	Depth from Zerene (experimental path)
        •	You already experimented with using a Zerene depth map as depth_idx.
        •	Long-term option: a “Use external depth” mode that:
        •	Loads a depth_idx-style map.
        •	Uses your fusion and color pipeline with that depth.

⸻

3. Fusion (PMax) itself

Goal: sharper, more Zerene-like output, fewer halos.
        1.	Merge consistency level
        •	Your Task_Merge has consistency levels:
        •	0 = pure max selection.
        •	1 = subband voting.
        •	2 = subband + neighbour denoise.
        •	Increasing this:
        •	Smooths depth decisions.
        •	Reduces “pepper noise” and small halos.
        •	Costs some CPU.
        2.	Wavelet levels / padding
        •	You now control levels via FSFusionWavelet and padding.
        •	More levels (deeper pyramid):
        •	Better separation of fine detail vs large blur.
        •	Sharper PMax but more sensitive to noise and halos.
        •	Fewer levels:
        •	Faster, a bit softer, often fewer halos.
        3.	Post-fusion local contrast
        •	After inverse wavelet, you can:
        •	Apply micro-contrast / clarity-style adjustment.
        •	Apply gentle tone-curve stretching.
        •	This can push your output visually closer to Zerene’s PMax “bite”.
        4.	Depth-aware blending between slices
        •	Instead of hard winner-take-all, you can:
        •	Blend neighbouring slices in depth where depth indices are close.
        •	That reduces seams along edges and some halo types.

⸻

4. Halo reduction

Goal: fix the bright/dark fringes around edges in the fused result.

You already have a FocusHalo subsystem in the original Winnow pipeline. For the Petteri path you have options:
        1.	Reuse your existing halo remover
        •	Run FocusHalo on the PMax output as a post-process.
        •	This is low-risk: you don’t touch the Petteri internals at first.
        2.	Depth-guided halo cleanup
        •	Detect strong local gradient + large depth jumps → likely halo region.
        •	Locally blend:
        •	Fused result with one of the source slices.
        •	Or with a more conservative focus measure.
        •	This targets halos only where depth changes abruptly.
        3.	More conservative PMax (less “aggressive” selection)
        •	Using consistency level 2 and maybe fewer levels:
        •	Often reduces halos at the cost of a slightly softer image.
        •	You can offer a “Zerene-like” vs “Aggressive PMax” preset.

⸻

5. Color handling and bit depth

Goal: best possible color and tonal smoothness, especially if you go to 16-bit output.
        1.	Keep color 16-bit as long as possible
        •	Aligned color already comes from 8- or 16-bit sources.
        •	Your current FSFusionReassign:
        •	Converts 16UC3 → 8UC3 for building the color map.
        •	Option:
        •	Still build the map in 8-bit space (for logic simplicity).
        •	Write 16-bit TIFF by scaling the chosen 8-bit color to 16-bit (×257).
        •	This preserves smoother gradients in the final file even if mapping logic is 8-bit.
        2.	Linear vs gamma-encoded color
        •	If aligned color is in gamma-encoded space (sRGB), PMax can over-emphasize highlights.
        •	Optional improvement:
        •	Convert color to a linearized space for reassignment, then re-encode to sRGB at the end.
        3.	White balance and exposure
        •	FSAlign already has matchWhiteBalance and matchContrast.
        •	Making sure color is consistent across stack:
        •	Reduces color flicker in the fused result.
        •	Helps the reassignment map stay compact and predictable.

⸻

6. Performance and usability

Goal: shorter run times and smoother UX without hurting quality.
        1.	Use in-memory Mats when available
        •	You are already partway there:
        •	m_alignedColorMats / m_alignedGrayMats from runAlign().
        •	When these are populated:
        •	Skip disk I/O entirely in runFusion().
        •	For 12×20MP stacks that’s a big quality-of-life win.
        2.	OpenCL toggle
        •	useOpenCL already gives a big speed-up in forward/inverse wavelet.
        •	For debugging or older GPUs:
        •	Allow a “CPU only” switch.
        •	For production:
        •	Default to OpenCL where stable → keep current good performance.
        3.	Parallelism at the slice level
        •	Forward wavelet per slice is embarrassingly parallel:
        •	You can run multiple slices at once using QtConcurrent or your own thread pool.
        •	Same for building the color map if you ever split it into tiles.
        4.	Preview vs final mode
        •	Fast “preview”:
        •	Fewer levels.
        •	Lower consistency.
        •	Maybe half-resolution input.
        •	“Final render”:
        •	Full levels, consistency 2, full-res.
        •	This would let you iterate on settings quickly.

⸻

7. Workflow / controls in Winnow

Goal: give you knobs without touching code each time.

Things that map nicely into UI options:
        •	PMax profile:
        •	“Fast” / “Balanced” / “Max Quality”.
        •	Consistency level: 0 / 1 / 2.
        •	Use OpenCL: on/off.
        •	Keep intermediates: on/off (already in Options).
        •	Output bit depth: 8-bit / 16-bit TIFF.
        •	Halo reduction: off / mild / strong.


We can start with clean, minimal versions that:
        •	Use in-memory Mats from runAlign()
        •	Save only if keepIntermediates==true
        •	Produce a real depth_index.png preview (you already have reference images)

Then later we enhance:
        •	Focus metric quality
        •	Depth smoothing
        •	Depth confidence
        •	Depth-aware halo reduction
