My Qt and c++ app, Winnow, reads the images in a folder.
It uses a class DataModel : public QStandardItemModel to keep track of information about each image in the folder.
It uses class ImageCache : public QThread to cache a QImage for each image into QHash<QString, QImage> imCache.
In the main gui thread the user can traverse thumbnails of each image in the folder.
As the position changes in the folder, it is sent to ImageCache::setCurrentPosition.
ImageCache::setTargetRange limits the size of imCache to maxSize, caching the images closest to the current position in a priority order.
ImageCache structures to keep track of what to cache next:
    int key; // the datamodel row for the image
    enum Status {NotCached, Caching, Cached};
    struct CacheStatus {
        Status status;
        int decoderId;
        int instance;
    };
    QList<int> toCache;
    QHash<int,CacheStatus> toCacheStatus;
class ImageDecoder : public QThread creates a QImage from an image file.
ImageCache::ImageCache creates multiple instances of ImageDecoder.
    QVector<ImageDecoder*> decoder;     // all the decoders
ImageCache::launchDecoders calls ImageCache::fillCache for each ImageDecoder.
ImageCache::fillCache checks the ImageDecoder, and if it has a QImage it inserts it into imCache and removes it from toCache and toCacheStatus.
ImageCache::fillCache then gets the next image from toCache and sends it to the ImageDecoder.
Each ImageDecoder signals ImageCache::fillCache with the QImage when it is done.
The ImageCache::fillCache / ImageDecoder cycle continues until toCache is empty.
void ImageCache::setCurrentPosition(QString fPath, QString src)
{
    key = dm->proxyRowFromPath(fPath);
    if (isRunning()) {
        setTargetRange();
    }
    else {
        start(QThread::LowestPriority);
    }
}

void ImageCache::run()
{
    setTargetRange();
    launchDecoders();
}

void ImageCache::launchDecoders(QString src)
{
    for (int id = 0; id < decoderCount; ++id) {
        if (decoder[id]->isRunning()) continue;
        fillCache(id);
    }
}

My problem is how to make sure setTargetRange() is always running in the ImageCache thread.  I think that isRunning() == false after
ImageCache::run() even though the ImageCache::fillCache / ImageDecoder cycle is running.
